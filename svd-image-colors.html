<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD Visualization with 3-Color Image</title>
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1/matrix.umd.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 5px;
            padding-bottom: 80px;
            /* Match reduced slider height */
            background-color: #f5f5f5;
            box-sizing: border-box;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
            min-height: calc(100vh - 100px);
            /* 100vh - padding-bottom - margins */
            box-sizing: border-box;
            overflow-x: auto;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: repeat(4, minmax(200px, 1fr));
            gap: clamp(15px, 3vw, 30px);
            margin-top: 10px;
            overflow-x: auto;
        }

        .rank1-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .rank1-title {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 30px 0 20px 0;
            color: #333;
        }

        .reconstruction-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .reconstruction-title {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 30px 0 20px 0;
            color: #333;
        }

        .matrix-section {
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .matrix-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            height: 20px;
            /* Fixed height for alignment */
            text-align: center;
            line-height: 16px;
            padding-top: 17px;
        }

        .matrix-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            height: 40px;
            /* Fixed height for alignment */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .matrix-canvas-container {
            height: 200px;
            /* Fixed height for canvas area */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        canvas {
            border: 2px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            height: auto;
        }

        .matrix-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 14px;
            min-height: 80px;
            /* Ensure consistent height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-grow: 1;
            /* Take remaining space */
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-top: 2px solid #007bff;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            height: 80px;
            /* Minimal height for low profile */
            box-sizing: border-box;
        }

        .slider-container {
            display: grid;
            grid-template-columns: repeat(3, minmax(150px, 1fr));
            gap: clamp(10px, 2vw, 15px);
            margin: 0;
            max-width: min(800px, 90vw);
            text-align: left;
            width: 100%;
        }

        .slider-group {
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.1);
            position: relative;
        }

        .slider-auto-adjusted {
            animation: sliderHighlight 0.5s ease;
        }

        @keyframes sliderHighlight {
            0% {
                border-color: rgba(0, 123, 255, 0.1);
            }

            50% {
                border-color: #007bff;
            }

            100% {
                border-color: rgba(0, 123, 255, 0.1);
            }
        }

        .slider-group h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 15px;
            font-weight: 600;
        }

        .slider-group label {
            display: block;
            margin-bottom: 4px;
            color: #666;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            margin-bottom: 10px;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            font-weight: bold;
            color: #007bff;
            font-size: 16px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .flattening-note {
            text-align: center;
            margin: 15px 0 5px 0;
            font-size: 14px;
            color: #666;
            font-style: italic;
        }

        .u-column-label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
            margin-top: 3px;
            height: 22px;
            line-height: 14px;
            overflow: hidden;
            white-space: nowrap;
            text-align: center;
            padding-top: 2px;
        }

        .u-column-info {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
            height: 14px;
            line-height: 14px;
        }

        .equation {
            text-align: center;
            margin: 30px 0 10px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        /* Responsive design */
        @media (max-width: 920px) {
            .visualization-container {
                grid-template-columns: repeat(2, 1fr);
                gap: clamp(10px, 2vw, 20px);
            }

            .matrix-canvas-container {
                height: auto;
                min-height: 150px;
            }
        }

        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
                gap: clamp(10px, 3vw, 15px);
            }

            .slider-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .controls {
                height: auto;
                min-height: 80px;
                padding: 10px 15px;
            }

            body {
                padding-bottom: 120px;
                /* Adjust for taller mobile controls */
            }

            h1 {
                font-size: clamp(18px, 4vw, 24px);
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }

            .matrix-title {
                font-size: clamp(14px, 4vw, 18px);
                height: 40px;
                padding-top: 12px;
            }

            .matrix-subtitle {
                font-size: clamp(11px, 3vw, 14px);
                height: 30px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>SVD Decomposition: Flattened Image Matrix A<sub>f</sub></h1>

        <div class="visualization-container">
            <div class="matrix-section">
                <div class="matrix-title">A</div>
                <div class="matrix-subtitle">Original [100×100×3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="originalImage" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">U</div>
                <div class="matrix-subtitle">Spatial Patterns [10,000 × 3]</div>
                <div class="matrix-canvas-container">
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <div style="text-align: center;">
                            <canvas id="uMatrix0" width="120" height="120"></canvas>
                            <div id="uLabel0" class="u-column-label">
                                U<sub>:,1</sub></div>
                            <div id="uShapeInfo0" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix1" width="120" height="120"></canvas>
                            <div id="uLabel1" class="u-column-label">
                                U<sub>:,2</sub></div>
                            <div id="uShapeInfo1" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix2" width="120" height="120"></canvas>
                            <div id="uLabel2" class="u-column-label">
                                U<sub>:,3</sub></div>
                            <div id="uShapeInfo2" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">Σ</div>
                <div class="matrix-subtitle">Importance Weights [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="sigmaMatrix" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">V<sup>T</sup></div>
                <div class="matrix-subtitle">Principal Color Axes [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="vMatrix" width="200" height="200"></canvas>
                </div>
            </div>
        </div>

        <div class="equation">
            A<sub>f</sub> = U × Σ × V<sup>T</sup> &nbsp;&nbsp;
        </div>
        <div class="flattening-note">
            A [100×100×3] → A<sub>f</sub> [10000×3]
        </div>

        <div class="controls">
            <div class="slider-container">
                <div class="slider-group" id="colorSliderGroup">
                    <label for="colorSlider">Colors: <span class="slider-value" id="colorValue">3</span></label>
                    <input type="range" id="colorSlider" class="slider" min="1" max="10" value="3"
                        oninput="updateSliders()">
                </div>
                <div class="slider-group" id="shapeSliderGroup">
                    <label for="shapeSlider">Shapes: <span class="slider-value" id="shapeValue">3</span></label>
                    <input type="range" id="shapeSlider" class="slider" min="1" max="10" value="3"
                        oninput="updateSliders()">
                </div>
                <div class="slider-group" id="rankSliderGroup">
                    <label for="rankSlider">Rank: <span class="slider-value" id="rankValue">3</span></label>
                    <input type="range" id="rankSlider" class="slider" min="0" max="3" value="3"
                        oninput="updateRankSlider()">
                </div>
            </div>
        </div>
    </div>

    <script>

        // Image dimensions
        const imageSize = 100;
        const canvasSize = 200;

        // Current image data
        let currentImageData = null;
        let currentSVD = null;
        let currentColorComplexity = 3;
        let currentShapeComplexity = 3;
        let currentRank = 3; // Current rank for approximation
        let isRankSliderActive = false; // Track if rank slider is being actively used
        let fixedShapes = null; // Store consistent shape positions and types

        // Initialize the visualization
        function init() {
            // Generate initial fixed shapes
            fixedShapes = generateShapes(currentShapeComplexity, []); // Empty colors initially
            generateComplexImage(currentColorComplexity, currentShapeComplexity);
            performSVD();

            // Set initial rank to match the actual rank and update slider limits
            updateRankSliderLimits();
            currentRank = Math.min(currentColorComplexity, 3);
            document.getElementById('rankSlider').value = currentRank;
            document.getElementById('rankValue').textContent = currentRank;

            // Set up rank slider interaction listeners
            setupRankSliderInteraction();

            drawAll();
        }

        // Update rank slider limits based on current color complexity
        function updateRankSliderLimits() {
            const actualRank = Math.min(currentColorComplexity, 3);
            const rankSlider = document.getElementById('rankSlider');

            // Update max value to match actual rank
            rankSlider.max = actualRank;

            // If current rank is higher than the new max, adjust it
            if (currentRank > actualRank) {
                currentRank = actualRank;
                rankSlider.value = currentRank;
                document.getElementById('rankValue').textContent = currentRank;
            }
        }

        // Set up rank slider interaction detection
        function setupRankSliderInteraction() {
            const rankSlider = document.getElementById('rankSlider');

            // Mouse events
            rankSlider.addEventListener('mousedown', () => {
                isRankSliderActive = true;
                // Immediately show highlighting when user starts dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('mouseup', () => {
                isRankSliderActive = false;
                // Hide highlighting when user stops dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            // Touch events for mobile
            rankSlider.addEventListener('touchstart', () => {
                isRankSliderActive = true;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('touchend', () => {
                isRankSliderActive = false;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });
        }

        // Update slider values and regenerate image
        function updateSliders() {
            const newColorComplexity = parseInt(document.getElementById('colorSlider').value);
            const newShapeComplexity = parseInt(document.getElementById('shapeSlider').value);

            // Auto-adjust logic: ensure we have enough shapes to support the color complexity
            let adjustedColorComplexity = newColorComplexity;
            let adjustedShapeComplexity = newShapeComplexity;

            // If user increases color complexity beyond shape complexity, increase shapes too
            if (newColorComplexity > currentShapeComplexity && newColorComplexity !== currentColorComplexity) {
                adjustedShapeComplexity = Math.max(newShapeComplexity, newColorComplexity);
                document.getElementById('shapeSlider').value = adjustedShapeComplexity;
                document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('shapeSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('shapeSliderGroup').classList.remove('slider-auto-adjusted');
                }, 500);

                // Show brief notification
                showSliderNotification(`Shape complexity automatically increased to ${adjustedShapeComplexity} to support ${newColorComplexity} colors`);
            }

            // If user decreases shape complexity below color complexity, decrease colors too
            if (newShapeComplexity < currentColorComplexity && newShapeComplexity !== currentShapeComplexity) {
                adjustedColorComplexity = Math.min(newColorComplexity, newShapeComplexity);
                document.getElementById('colorSlider').value = adjustedColorComplexity;
                document.getElementById('colorValue').textContent = adjustedColorComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('colorSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('colorSliderGroup').classList.remove('slider-auto-adjusted');
                }, 500);

                // Show brief notification
                showSliderNotification(`Color complexity automatically decreased to ${adjustedColorComplexity} to match ${newShapeComplexity} shapes`);
            }

            // Update display values
            document.getElementById('colorValue').textContent = adjustedColorComplexity;
            document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

            // Add or remove shapes if shape complexity changed
            if (adjustedShapeComplexity !== currentShapeComplexity) {
                if (adjustedShapeComplexity > currentShapeComplexity) {
                    addShapesToPattern(adjustedShapeComplexity - currentShapeComplexity);
                }
            }

            currentColorComplexity = adjustedColorComplexity;
            currentShapeComplexity = adjustedShapeComplexity;

            generateComplexImage(currentColorComplexity, currentShapeComplexity);
            performSVD();

            // Update rank slider limits and preserve current rank if still valid
            updateRankSliderLimits();

            drawAll();
        }

        // Update rank slider and display approximation
        function updateRankSlider() {
            const newRank = parseInt(document.getElementById('rankSlider').value);
            currentRank = newRank;

            // Update display value
            document.getElementById('rankValue').textContent = currentRank;

            // Update the title based on rank
            updateImageTitle();

            // Redraw with current highlighting state (depends on isRankSliderActive)
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateULabels();
        }        // Briefly highlight all components at full rank, then fade to default
        function brieflyHighlightFullRank() {
            // Temporarily set a flag to force highlighting
            window.showFullRankHighlight = true;

            // Redraw with highlighting
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateULabels();

            // After 1200ms, fade to default appearance
            setTimeout(() => {
                window.showFullRankHighlight = false;
                drawOriginalImageWithRank();
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            }, 400);
        }        // Update image subtitle based on current rank
        function updateImageTitle() {
            const subtitleElement = document.querySelector('.matrix-subtitle');
            const actualRank = Math.min(currentColorComplexity, 3); // Actual rank of the image

            if (currentRank === actualRank) {
                subtitleElement.innerHTML = 'Original [100×100×3]';
            } else if (currentRank === 0) {
                subtitleElement.innerHTML = 'Zero [100×100×3]';
            } else {
                subtitleElement.innerHTML = `Rank-${currentRank} Approximation [100×100×3]`;
            }
        }

        // Add notification function
        function showSliderNotification(message) {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('sliderNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'sliderNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #007bff;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 10000;
                    font-size: 14px;
                    max-width: 400px;
                    text-align: center;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(notification);
            }

            // Show notification
            notification.textContent = message;
            notification.style.opacity = '1';

            // Hide after 2.5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2500);
        }

        function generateComplexImage(colorComplexity, shapeComplexity) {
            // Initialize image with background
            currentImageData = new Array(imageSize);
            for (let i = 0; i < imageSize; i++) {
                currentImageData[i] = new Array(imageSize);
                for (let j = 0; j < imageSize; j++) {
                    currentImageData[i][j] = [0, 0, 0]; // Black background
                }
            }

            // Generate color palette based on complexity
            const colors = getColorPalette(colorComplexity);

            // Use fixed shapes but apply current colors
            const shapesToDraw = assignColorsToFixedShapes(fixedShapes, colors, shapeComplexity);

            // Draw shapes to the image
            drawShapes(shapesToDraw);
        }

        function assignColorsToFixedShapes(shapes, colors, shapeComplexity) {
            // Take only the number of shapes we want based on current complexity
            const activeShapes = shapes.slice(0, Math.min(shapeComplexity, shapes.length));

            // Debug: Log color assignment
            console.log(`Assigning colors: ${colors.length} colors available for ${activeShapes.length} shapes`);

            // Always reassign colors cyclically to ensure color changes are reflected
            // This ensures that when color complexity changes, all shapes get new color assignments
            const shapesWithColors = activeShapes.map((shape, index) => {
                const assignedColor = colors.length > 0 ? colors[index % colors.length] : [255, 255, 255];
                console.log(`Shape ${index}: type=${shape.type}, color=[${assignedColor.join(',')}]`);
                return {
                    ...shape,
                    color: assignedColor
                };
            });

            return shapesWithColors;
        }

        function getColorPalette(complexity) {
            const baseColors = [
                [255, 0, 0],    // Red
                [0, 255, 0],    // Green  
                [0, 0, 255],    // Blue
                [255, 255, 0],  // Yellow
                [255, 0, 255],  // Magenta
                [0, 255, 255],  // Cyan
                [255, 128, 0],  // Orange
                [128, 0, 255],  // Purple
                [255, 192, 203], // Pink
                [128, 255, 0]   // Lime
            ];

            return baseColors.slice(0, Math.min(complexity, baseColors.length));
        }

        function generateShapes(complexity, colors) {
            const shapes = [];
            const shapeTypes = ['circle', 'rectangle', 'triangle', 'diamond', 'pentagon', 'hexagon', 'star', 'ellipse', 'cross', 'heart'];

            // Generate up to 10 shapes with fixed positions but no colors yet
            for (let i = 0; i < Math.min(10, 10); i++) { // Always generate 10 potential shapes
                const shapeType = shapeTypes[i % shapeTypes.length];

                shapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }

            return shapes;
        }

        function addShapesToPattern(numNewShapes) {
            const shapeTypes = ['circle', 'rectangle', 'triangle', 'diamond', 'pentagon', 'hexagon', 'star', 'ellipse', 'cross', 'heart'];

            // Add new shapes to the existing pattern
            for (let i = 0; i < numNewShapes && fixedShapes.length < 10; i++) {
                const currentShapeIndex = fixedShapes.length;
                const shapeType = shapeTypes[currentShapeIndex % shapeTypes.length];

                fixedShapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }
        }

        function drawShapes(shapes) {
            shapes.forEach(shape => {
                switch (shape.type) {
                    case 'circle':
                        drawCircle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'rectangle':
                        drawRectangle(shape.x, shape.y, shape.size, shape.size, shape.color);
                        break;
                    case 'triangle':
                        drawTriangle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'diamond':
                        drawDiamond(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'pentagon':
                        drawPolygon(shape.x, shape.y, shape.size, 5, shape.color, shape.rotation);
                        break;
                    case 'hexagon':
                        drawPolygon(shape.x, shape.y, shape.size, 6, shape.color, shape.rotation);
                        break;
                    case 'star':
                        drawStar(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'ellipse':
                        drawEllipse(shape.x, shape.y, shape.size, shape.size * 0.7, shape.color);
                        break;
                    case 'cross':
                        drawCross(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'heart':
                        drawHeart(shape.x, shape.y, shape.size, shape.color);
                        break;
                }
            });
        }

        function drawCircle(cx, cy, radius, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dist = Math.sqrt((i - cy) ** 2 + (j - cx) ** 2);
                    if (dist <= radius) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawRectangle(x, y, width, height, color) {
            for (let i = Math.max(0, Math.floor(y)); i < Math.min(imageSize, Math.ceil(y + height)); i++) {
                for (let j = Math.max(0, Math.floor(x)); j < Math.min(imageSize, Math.ceil(x + width)); j++) {
                    if (i >= 0 && i < imageSize && j >= 0 && j < imageSize) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawTriangle(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Simple right triangle
                    const relativeI = i - cy;
                    const relativeJ = j - cx;
                    if (relativeJ >= 0 && relativeI >= 0 && relativeJ < (size - relativeI) && relativeI < size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawDiamond(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = Math.abs(j - cx);
                    const dy = Math.abs(i - cy);
                    if (dx + dy <= size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawPolygon(cx, cy, size, sides, color, rotation) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx) + rotation;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Approximate polygon as circle for simplicity
                    const polygonRadius = size * Math.cos(Math.PI / sides) / Math.cos((angle % (2 * Math.PI / sides)) - Math.PI / sides);
                    if (dist <= Math.abs(polygonRadius) && dist <= size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawStar(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Simple 5-pointed star approximation
                    const starAngle = ((angle + Math.PI) % (2 * Math.PI / 5)) - Math.PI / 5;
                    const starRadius = size * (0.5 + 0.5 * Math.cos(5 * starAngle));
                    if (dist <= starRadius) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawEllipse(cx, cy, width, height, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / width;
                    const dy = (i - cy) / height;
                    if (dx * dx + dy * dy <= 1) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawCross(cx, cy, size, color) {
            const thickness = Math.max(3, Math.floor(size / 4));
            // Horizontal bar
            const hx = Math.floor(cx - size);
            const hy = Math.floor(cy - thickness / 2);
            const hwidth = Math.floor(size * 2);
            const hheight = Math.floor(thickness);
            drawRectangle(hx, hy, hwidth, hheight, color);

            // Vertical bar  
            const vx = Math.floor(cx - thickness / 2);
            const vy = Math.floor(cy - size);
            const vwidth = Math.floor(thickness);
            const vheight = Math.floor(size * 2);
            drawRectangle(vx, vy, vwidth, vheight, color);
        }

        function drawHeart(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / size;
                    const dy = (i - cy) / size;

                    // Heart equation approximation
                    const heartEq = Math.pow(dx * dx + dy * dy - 1, 3) - dx * dx * dy * dy * dy;
                    if (heartEq <= 0 && dx * dx + dy * dy <= 2) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function generateSimple3ColorImage() {
            generateComplexImage(3, 3);
        }

        function performSVD() {
            // Convert the 3D image array (100x100x3) into a 2D matrix (10000x3)
            // Each row represents a pixel with its RGB values
            const imageMatrix = [];
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Normalize to 0-1 range for better numerical stability
                    const [r, g, b] = currentImageData[i][j];
                    imageMatrix.push([r / 255, g / 255, b / 255]);
                }
            }

            // Perform actual SVD from scratch
            currentSVD = computeSVDFromScratch(imageMatrix);

            console.log('SVD Results:');
            console.log('Singular values:', currentSVD.sigma);
            console.log('U dimensions:', currentSVD.U.length, 'x', currentSVD.U[0].length);
            console.log('VT dimensions:', currentSVD.VT.length, 'x', currentSVD.VT[0].length);
        }



        function computeSVDFromScratch(matrix) {
            const A = new mlMatrix.Matrix(matrix);

            // Perform SVD
            const svd = new mlMatrix.SingularValueDecomposition(A);

            // Extract components
            const U = svd.leftSingularVectors.to2DArray();
            const sigma = svd.diagonal;
            const V = svd.rightSingularVectors.to2DArray();

            // Transpose V to get V^T (ML-Matrix returns V, but we need V^T)
            const VT = [];
            for (let i = 0; i < V[0].length; i++) {
                VT[i] = [];
                for (let j = 0; j < V.length; j++) {
                    VT[i][j] = V[j][i];
                }
            }

            // Fix sign ambiguity: make the largest absolute value in each V^T row positive
            for (let i = 0; i < VT.length; i++) {
                const row = VT[i];
                let maxAbsIdx = 0;
                let maxAbsVal = Math.abs(row[0]);

                for (let j = 1; j < row.length; j++) {
                    if (Math.abs(row[j]) > maxAbsVal) {
                        maxAbsVal = Math.abs(row[j]);
                        maxAbsIdx = j;
                    }
                }

                // If the largest element is negative, flip the sign of the entire row
                // and corresponding column in U
                if (row[maxAbsIdx] < 0) {
                    for (let j = 0; j < row.length; j++) {
                        VT[i][j] = -VT[i][j];
                    }
                    for (let k = 0; k < U.length; k++) {
                        U[k][i] = -U[k][i];
                    }
                }
            }

            return { U, sigma, VT };
        }

        function drawAll() {
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            drawRank1Components();
            drawReconstructions();
            updateSigmaValues();
            updateImageTitle();
        }

        function drawOriginalImage() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvasSize, canvasSize);

            for (let i = 0; i < canvasSize; i++) {
                for (let j = 0; j < canvasSize; j++) {
                    // Map canvas coordinates to image coordinates
                    const imgI = Math.floor(i * imageSize / canvasSize);
                    const imgJ = Math.floor(j * imageSize / canvasSize);

                    const pixelIndex = (i * canvasSize + j) * 4;
                    const [r, g, b] = currentImageData[imgI][imgJ];

                    imageData.data[pixelIndex] = r;     // Red
                    imageData.data[pixelIndex + 1] = g; // Green
                    imageData.data[pixelIndex + 2] = b; // Blue
                    imageData.data[pixelIndex + 3] = 255; // Alpha
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function drawOriginalImageWithRank() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvasSize, canvasSize);

            if (currentRank === 0) {
                // Black image for rank 0
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = 0;     // Red
                    imageData.data[i + 1] = 0; // Green
                    imageData.data[i + 2] = 0; // Blue
                    imageData.data[i + 3] = 255; // Alpha
                }
            } else {
                // Compute rank-k approximation
                for (let i = 0; i < canvasSize; i++) {
                    for (let j = 0; j < canvasSize; j++) {
                        // Map canvas coordinates to image coordinates
                        const imgI = Math.floor(i * imageSize / canvasSize);
                        const imgJ = Math.floor(j * imageSize / canvasSize);
                        const flatIndex = imgI * imageSize + imgJ;

                        // Compute rank-k approximation: sum of first k rank-1 components
                        let r = 0, g = 0, b = 0;
                        for (let k = 0; k < currentRank; k++) {
                            const sigma = currentSVD.sigma[k];
                            const u_val = currentSVD.U[flatIndex][k];
                            const v_r = currentSVD.VT[k][0];
                            const v_g = currentSVD.VT[k][1];
                            const v_b = currentSVD.VT[k][2];

                            r += u_val * sigma * v_r;
                            g += u_val * sigma * v_g;
                            b += u_val * sigma * v_b;
                        }

                        // Scale and clamp to [0, 255]
                        r = Math.max(0, Math.min(255, r * 255));
                        g = Math.max(0, Math.min(255, g * 255));
                        b = Math.max(0, Math.min(255, b * 255));

                        const pixelIndex = (i * canvasSize + j) * 4;
                        imageData.data[pixelIndex] = r;     // Red
                        imageData.data[pixelIndex + 1] = g; // Green
                        imageData.data[pixelIndex + 2] = b; // Blue
                        imageData.data[pixelIndex + 3] = 255; // Alpha
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        let hoveredVTRow = -1; // Track which V^T row is being hovered

        function updateULabels() {
            for (let i = 0; i < 3; i++) {
                const label = document.getElementById(`uLabel${i}`);
                const shapeInfo = document.getElementById(`uShapeInfo${i}`);
                const isActive = (hoveredVTRow === i) ||
                    (isRankSliderActive && i < currentRank) ||
                    (window.showFullRankHighlight && i < 3); if (isActive) {
                        label.innerHTML = `σ<sub>${i + 1}</sub>u<sub>${i + 1}</sub>v<sub>${i + 1}</sub><sup>T</sup>`;
                        label.style.color = '#007bff';
                        shapeInfo.innerHTML = `→ [100 × 100]`;
                        shapeInfo.style.color = '#007bff';
                    } else {
                    label.innerHTML = `U<sub>:,${i + 1}</sub>`;
                    label.style.color = '#333';
                    shapeInfo.innerHTML = `→ [100 × 100]`;
                    shapeInfo.style.color = '#666';
                }
            }
        }

        function drawUMatrix() {
            // Draw each U column as a separate square canvas
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);
                const ctx = canvas.getContext('2d');
                const canvasSize = 120; // Size of each individual canvas

                // Clear canvas
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // Find min/max for normalization for this column
                let minVal = Infinity, maxVal = -Infinity;
                for (let i = 0; i < currentSVD.U.length; i++) {
                    const val = currentSVD.U[i][col];
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                }

                // Determine if this column should be colored based on V^T hover or rank approximation
                const shouldColor = (hoveredVTRow === col) ||
                    (isRankSliderActive && col < currentRank) ||
                    (window.showFullRankHighlight && col < 3);                // Draw column as square heatmap (unsquished)
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const idx = i * imageSize + j;
                        const val = currentSVD.U[idx][col];

                        if (shouldColor) {
                            // Use the exact same calculation as rank-1 components
                            const sigma = currentSVD.sigma[col];
                            const vRow = currentSVD.VT[col];
                            const uValue = currentSVD.U[idx][col];

                            // Calculate u_i * sigma_i * v_i^T for this pixel (same as rank-1 components)
                            const r = Math.max(0, Math.min(255, uValue * sigma * vRow[0] * 255));
                            const g = Math.max(0, Math.min(255, uValue * sigma * vRow[1] * 255));
                            const b = Math.max(0, Math.min(255, uValue * sigma * vRow[2] * 255));

                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            // Default grayscale
                            const normalized = (val - minVal) / (maxVal - minVal);
                            const intensity = Math.floor(normalized * 255);
                            ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                        }

                        // Map to square canvas coordinates
                        const x = (j / imageSize) * canvasSize;
                        const y = (i / imageSize) * canvasSize;
                        const w = canvasSize / imageSize;
                        const h = canvasSize / imageSize;

                        ctx.fillRect(x, y, w + 1, h + 1);
                    }
                }
            }

            // Set up hover interactions for each U matrix canvas
            setupUMatrixInteraction();
        }

        function setupUMatrixInteraction() {
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);

                // Remove existing listeners to prevent duplicates
                canvas.onmouseover = null;
                canvas.onmouseleave = null;

                canvas.onmouseover = function () {
                    if (hoveredVTRow !== col) {
                        hoveredVTRow = col;
                        drawUMatrix(); // Redraw U matrix with coloring
                        drawSigmaMatrix(); // Redraw sigma matrix with coloring
                        drawVMatrix(); // Redraw V matrix with highlighting
                        updateULabels(); // Update labels to show principal component
                    }
                };

                canvas.onmouseleave = function () {
                    if (hoveredVTRow === col) {
                        hoveredVTRow = -1;
                        drawUMatrix(); // Redraw U matrix without coloring
                        drawSigmaMatrix(); // Redraw sigma matrix without coloring
                        drawVMatrix(); // Redraw V matrix without highlighting
                        updateULabels(); // Reset labels to original text
                    }
                };
            }
        }

        function drawSigmaMatrix() {
            const canvas = document.getElementById('sigmaMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // Draw singular values as bars
            const maxSigma = Math.max(...currentSVD.sigma);
            const barWidth = canvasSize / currentSVD.sigma.length;
            const margin = 20;

            for (let i = 0; i < currentSVD.sigma.length; i++) {
                const height = ((currentSVD.sigma[i] / maxSigma) * (canvasSize - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = canvasSize - margin - height;
                const w = barWidth * 0.8;

                // Color bar blue if this component is hovered or part of current rank approximation, gray otherwise
                ctx.fillStyle = (hoveredVTRow === i) ||
                    (isRankSliderActive && i < currentRank) ||
                    (window.showFullRankHighlight && i < 3) ? '#007bff' : '#999';
                ctx.fillRect(x, y, w, height);

                // Add value label
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentSVD.sigma[i].toFixed(1), i * barWidth + barWidth / 2, canvasSize - 5);
                ctx.fillText(`σ${i + 1}`, i * barWidth + barWidth / 2, y - 5);
            }

            // Set up hover interactions for sigma matrix
            setupSigmaMatrixInteraction(canvas, barWidth);
        }

        function setupSigmaMatrixInteraction(canvas, barWidth) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;

                // Determine which bar is being hovered
                const col = Math.floor(x / barWidth);

                if (col >= 0 && col < 3 && col !== hoveredVTRow) {
                    hoveredVTRow = col;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (hoveredVTRow !== -1) {
                    hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        function drawVMatrix() {
            const canvas = document.getElementById('vMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const cellSize = canvasSize / 3;

            // Find global min/max for consistent coloring
            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i < currentSVD.VT.length; i++) {
                for (let j = 0; j < currentSVD.VT[i].length; j++) {
                    minVal = Math.min(minVal, currentSVD.VT[i][j]);
                    maxVal = Math.max(maxVal, currentSVD.VT[i][j]);
                }
            }

            // Calculate row colors first for consistent coloring
            const rowColors = [];
            const rowNames = [];

            for (let i = 0; i < 3; i++) {
                const row = currentSVD.VT[i];

                // Get the RGB values for this row (how this component mixes colors)
                const rVal = Math.abs(row[0]);
                const gVal = Math.abs(row[1]);
                const bVal = Math.abs(row[2]);

                // Normalize to 0-255 range for color display
                const maxVal = Math.max(rVal, gVal, bVal);
                const r = Math.floor((rVal / maxVal) * 255);
                const g = Math.floor((gVal / maxVal) * 255);
                const b = Math.floor((bVal / maxVal) * 255);

                // Create a lighter version of the color for background (add transparency effect)
                const lightRowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
                const rowColor = `rgb(${r}, ${g}, ${b})`;

                rowColors.push({ light: lightRowColor, full: rowColor });

                // Determine the dominant color name
                if (rVal > gVal && rVal > bVal) {
                    rowNames.push('Red');
                } else if (gVal > rVal && gVal > bVal) {
                    rowNames.push('Green');
                } else {
                    rowNames.push('Blue');
                }
            }

            // Draw matrix cells with colored row backgrounds
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const val = currentSVD.VT[i][j];

                    // Use the row's light color as background (no color changes)
                    ctx.fillStyle = rowColors[i].light;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Draw normal border for all cells
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Add value text (always black since we use light colors)
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        val.toFixed(3),
                        j * cellSize + cellSize / 2,
                        i * cellSize + cellSize / 2 + 5
                    );
                }
            }

            // Draw shadow box around hovered row or active rank components
            for (let i = 0; i < 3; i++) {
                const shouldHighlight = (hoveredVTRow === i) ||
                    (isRankSliderActive && i < currentRank) ||
                    (window.showFullRankHighlight && i < 3); if (shouldHighlight) {
                        const rowY = i * cellSize;
                        const margin = 6; // Margin to keep shadow within canvas bounds

                        // Create shadow effect
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;

                        // Draw shadow box around the entire row, inset by margin
                        ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(margin, rowY + margin, canvasSize - 2 * margin, cellSize - 2 * margin);

                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
            }

            // Draw row labels with full color backgrounds
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';

            for (let i = 0; i < 3; i++) {
                // Draw colored background for the row label
                const labelX = -45;
                const labelY = i * cellSize + cellSize / 2 - 7;
                const labelWidth = 40;
                const labelHeight = 14;

                ctx.fillStyle = rowColors[i].full;
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

                // Draw contrasting text
                const r = parseInt(rowColors[i].full.match(/\d+/g)[0]);
                const g = parseInt(rowColors[i].full.match(/\d+/g)[1]);
                const b = parseInt(rowColors[i].full.match(/\d+/g)[2]);
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                ctx.fillStyle = brightness > 127 ? 'black' : 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(rowNames[i], labelX + labelWidth / 2, labelY + 10);
            }

            // Add mouse event listeners for hover interaction
            setupVMatrixInteraction(canvas, cellSize);
        }

        function setupVMatrixInteraction(canvas, cellSize) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Determine which row is being hovered
                const row = Math.floor(y / cellSize);

                if (row >= 0 && row < 3 && row !== hoveredVTRow) {
                    hoveredVTRow = row;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (hoveredVTRow !== -1) {
                    hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        function drawRank1Components() {
            for (let component = 0; component < 3; component++) {
                drawRank1Component(component);
            }
        }

        function drawRank1Component(componentIndex) {
            const canvas = document.getElementById(`rank1Component${componentIndex + 1}`);
            const ctx = canvas.getContext('2d');

            // Calculate the rank-1 component: u_i * sigma_i * v_i^T
            const componentImageData = calculateRank1ComponentImage(componentIndex);

            const imageData = ctx.createImageData(canvasSize, canvasSize);

            for (let i = 0; i < canvasSize; i++) {
                for (let j = 0; j < canvasSize; j++) {
                    // Map canvas coordinates to image coordinates
                    const imgI = Math.floor(i * imageSize / canvasSize);
                    const imgJ = Math.floor(j * imageSize / canvasSize);

                    const pixelIndex = (i * canvasSize + j) * 4;
                    const [r, g, b] = componentImageData[imgI][imgJ];

                    // Clamp values to 0-255 range
                    imageData.data[pixelIndex] = Math.max(0, Math.min(255, r));     // Red
                    imageData.data[pixelIndex + 1] = Math.max(0, Math.min(255, g)); // Green
                    imageData.data[pixelIndex + 2] = Math.max(0, Math.min(255, b)); // Blue
                    imageData.data[pixelIndex + 3] = 255; // Alpha
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function calculateRank1ComponentImage(componentIndex) {
            const componentImage = new Array(imageSize);
            const sigma = currentSVD.sigma[componentIndex];
            const vRow = currentSVD.VT[componentIndex];

            // Debug: Log the V^T row being used
            console.log(`Component ${componentIndex}: sigma=${sigma.toFixed(3)}, vRow=[${vRow.map(v => v.toFixed(3)).join(', ')}]`);

            for (let i = 0; i < imageSize; i++) {
                componentImage[i] = new Array(imageSize);
                for (let j = 0; j < imageSize; j++) {
                    const spatialIndex = i * imageSize + j;
                    const uValue = currentSVD.U[spatialIndex][componentIndex];

                    // Calculate u_i * sigma_i * v_i^T for this pixel
                    // Scale back to 0-255 range since input was normalized
                    const r = uValue * sigma * vRow[0] * 255;
                    const g = uValue * sigma * vRow[1] * 255;
                    const b = uValue * sigma * vRow[2] * 255;

                    componentImage[i][j] = [r, g, b];
                }
            }

            return componentImage;
        }

        function drawReconstructions() {
            drawRankKReconstruction(2, 'rank2Reconstruction');
            drawRankKReconstruction(3, 'fullReconstruction');
        }

        function drawRankKReconstruction(k, canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            // Calculate the rank-k reconstruction by summing the first k components
            const reconstructedImageData = calculateRankKReconstructionImage(k);

            const imageData = ctx.createImageData(canvasSize, canvasSize);

            for (let i = 0; i < canvasSize; i++) {
                for (let j = 0; j < canvasSize; j++) {
                    // Map canvas coordinates to image coordinates
                    const imgI = Math.floor(i * imageSize / canvasSize);
                    const imgJ = Math.floor(j * imageSize / canvasSize);

                    const pixelIndex = (i * canvasSize + j) * 4;
                    const [r, g, b] = reconstructedImageData[imgI][imgJ];

                    // Clamp values to 0-255 range
                    imageData.data[pixelIndex] = Math.max(0, Math.min(255, r));     // Red
                    imageData.data[pixelIndex + 1] = Math.max(0, Math.min(255, g)); // Green
                    imageData.data[pixelIndex + 2] = Math.max(0, Math.min(255, b)); // Blue
                    imageData.data[pixelIndex + 3] = 255; // Alpha
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function calculateRankKReconstructionImage(k) {
            const reconstructedImage = new Array(imageSize);

            // Initialize with zeros
            for (let i = 0; i < imageSize; i++) {
                reconstructedImage[i] = new Array(imageSize);
                for (let j = 0; j < imageSize; j++) {
                    reconstructedImage[i][j] = [0, 0, 0];
                }
            }

            // Sum the first k components: A_k = sum(u_i * sigma_i * v_i^T)
            for (let component = 0; component < k; component++) {
                const sigma = currentSVD.sigma[component];
                const vRow = currentSVD.VT[component];

                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const spatialIndex = i * imageSize + j;
                        const uValue = currentSVD.U[spatialIndex][component];

                        // Proper SVD reconstruction: u_i * sigma_i * v_i^T
                        // Scale back to 0-255 range since input was normalized
                        reconstructedImage[i][j][0] += uValue * sigma * vRow[0] * 255;
                        reconstructedImage[i][j][1] += uValue * sigma * vRow[1] * 255;
                        reconstructedImage[i][j][2] += uValue * sigma * vRow[2] * 255;
                    }
                }
            }

            return reconstructedImage;
        }

        function updateSigmaValues() {
            // Update the displayed sigma values
            document.getElementById('sigma1Value').textContent = currentSVD.sigma[0].toFixed(1);
            document.getElementById('sigma2Value').textContent = currentSVD.sigma[1].toFixed(1);
            document.getElementById('sigma3Value').textContent = currentSVD.sigma[2].toFixed(1);
        }

        function generateNewImage() {
            // Generate completely new shapes when user clicks "Generate New Pattern"
            fixedShapes = generateShapes(currentShapeComplexity, []);
            generateComplexImage(currentColorComplexity, currentShapeComplexity);
            performSVD();
            drawAll();
        }

        init();
    </script>
</body>

</html>