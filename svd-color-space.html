<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD in Color Space</title>
    <link rel="icon" type="image/x-icon" href="assets/svd-color-space.svg">
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1/matrix.umd.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 5px;
            padding-bottom: 80px;
            /* Match reduced slider height */
            background-color: #f5f5f5;
            box-sizing: border-box;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
            min-height: calc(100vh - 100px);
            /* 100vh - padding-bottom - margins */
            box-sizing: border-box;
            overflow-x: auto;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: repeat(4, minmax(200px, 1fr));
            gap: clamp(15px, 3vw, 30px);
            margin-top: 10px;
            overflow-x: auto;
        }

        .matrix-section {
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .matrix-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            height: 20px;
            /* Fixed height for alignment */
            text-align: center;
            line-height: 16px;
            padding-top: 17px;
        }

        .matrix-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            height: 40px;
            /* Fixed height for alignment */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .matrix-canvas-container {
            height: 200px;
            /* Fixed height for canvas area */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        canvas {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            height: auto;
        }

        .matrix-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 14px;
            min-height: 80px;
            /* Ensure consistent height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-grow: 1;
            /* Take remaining space */
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-top: 2px solid #007bff;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            height: 80px;
            /* Minimal height for low profile */
            box-sizing: border-box;
        }

        .slider-container {
            display: grid;
            grid-template-columns: repeat(3, minmax(150px, 1fr));
            gap: clamp(10px, 2vw, 15px);
            margin: 0;
            max-width: min(800px, 90vw);
            text-align: left;
            width: 100%;
        }

        .slider-group {
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.1);
            position: relative;
        }

        .slider-auto-adjusted {
            animation: sliderHighlight 0.5s ease;
        }

        @keyframes sliderHighlight {
            0% {
                border-color: rgba(0, 123, 255, 0.1);
            }

            50% {
                border-color: #007bff;
            }

            100% {
                border-color: rgba(0, 123, 255, 0.1);
            }
        }

        .slider-group h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 15px;
            font-weight: 600;
        }

        .slider-group label {
            display: block;
            margin-bottom: 4px;
            color: #666;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            margin-bottom: 10px;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            font-weight: bold;
            color: #007bff;
            font-size: 16px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .flattening-note {
            text-align: center;
            margin: 15px 0 5px 0;
            font-size: 14px;
            color: #666;
            font-style: italic;
        }

        .u-column-label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
            margin-top: 3px;
            height: 22px;
            line-height: 14px;
            overflow: hidden;
            white-space: nowrap;
            text-align: center;
            padding-top: 2px;
        }

        .u-column-info {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
            height: 14px;
            line-height: 14px;
        }

        .equation {
            text-align: center;
            margin: 30px 0 10px;
            font-size: 18px;
            height: 30px;
            font-weight: bold;
            color: #333;
        }

        /* Responsive design */
        @media (max-width: 1016px) {

            h1,
            .equation,
            .flattening-note {
                margin: 0;
            }


            .visualization-container {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: auto auto;
                gap: 0;
            }

            .matrix-title {
                padding-top: 0;
            }

            .matrix-subtitle {
                margin-bottom: 0;
                height: 30px;
            }

            .matrix-section:first-child {
                grid-column: 2 / 3;
                /* Center the Original Image in top row */
                grid-row: 1;
            }

            .matrix-section:nth-child(2) {
                grid-column: 1 / 2;
                /* U Matrix in bottom left */
                grid-row: 2;
            }

            .matrix-section:nth-child(3) {
                grid-column: 2 / 3;
                /* Σ Matrix in bottom center */
                grid-row: 2;
            }

            .matrix-section:nth-child(4) {
                grid-column: 3 / 4;
                /* V^T Matrix in bottom right */
                grid-row: 2;
            }

            .matrix-canvas-container {
                height: auto;
                min-height: 150px;
            }
        }

        @media (max-width: 705px) {
            .visualization-container {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(2, auto);
                gap: clamp(10px, 2vw, 20px);
            }

            .matrix-section:first-child {
                grid-column: 1 / 2;
                /* Original Image top left */
                grid-row: 1;
            }

            .matrix-section:nth-child(2) {
                grid-column: 2 / 3;
                /* U Matrix top right */
                grid-row: 1;
            }

            .matrix-section:nth-child(3) {
                grid-column: 1 / 2;
                /* Σ Matrix bottom left */
                grid-row: 2;
            }

            .matrix-section:nth-child(4) {
                grid-column: 2 / 3;
                /* V^T Matrix bottom right */
                grid-row: 2;
            }

            .matrix-canvas-container {
                height: auto;
                min-height: 120px;
            }

            .slider-container {
                grid-template-columns: repeat(3, minmax(120px, 1fr));
                gap: clamp(8px, 1.5vw, 12px);
                max-width: min(700px, 95vw);
                padding: 0 5px;
            }

            .controls {
                height: auto;
                min-height: 80px;
                padding: 10px 15px;
            }

            body {
                padding-bottom: 120px;
                /* Adjust for taller mobile controls */
            }

            h1 {
                font-size: clamp(18px, 4vw, 24px);
            }
        }

        @media (max-width: 492px) {
            .container {
                display: flex;
                flex-direction: column;
            }

            h1 {
                order: 0;
            }

            .equation {
                order: 1;
                margin: 5px 0 0;
                font-size: 16px;
                height: 25px;
            }

            .flattening-note {
                order: 2;
                font-size: 11px;
            }

            .visualization-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
                gap: 0;
                order: 3;
            }

            .matrix-section:first-child,
            .matrix-section:nth-child(2),
            .matrix-section:nth-child(3),
            .matrix-section:nth-child(4) {
                grid-column: 1;
                grid-row: auto;
            }

            .matrix-title {
                display: none;
            }

            .matrix-section:first-child .matrix-subtitle::before {
                content: "A:\00a0";
                font-weight: bold;
            }

            .matrix-section:nth-child(2) .matrix-subtitle::before {
                content: "U:\00a0";
                font-weight: bold;
            }

            .matrix-section:nth-child(3) .matrix-subtitle::before {
                content: "Σ:\00a0";
                font-weight: bold;
            }

            .matrix-section:nth-child(4) .matrix-subtitle::before {
                content: "V\1D40:\00a0";
                font-weight: bold;
            }

            .matrix-canvas-container {
                height: auto;
                min-height: 100px;
            }

            .slider-container {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .slider-group {
                padding: 6px 8px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .slider-group label {
                margin-bottom: 0;
                font-size: 12px;
                white-space: nowrap;
            }

            .slider {
                flex: 1;
                margin: 0;
            }

            .slider-value {
                min-width: 20px;
                text-align: center;
                font-size: 12px;
            }

            .controls {
                height: auto;
                min-height: 90px;
                padding: 6px 10px;
            }

            body {
                padding-bottom: 110px;
            }

            .container {
                padding: 8px;
            }

            /* RGB mode overrides for mobile */
            .rgb-mode .matrix-section:nth-child(2) .matrix-subtitle::before {
                content: "A_f:\00a0";
                font-weight: bold;
            }

            .rgb-mode .matrix-section:nth-child(3) .matrix-subtitle::before {
                content: "Σ:\00a0";
                font-weight: bold;
            }

            .rgb-mode .matrix-section:nth-child(4) .matrix-subtitle::before {
                content: "I:\00a0";
                font-weight: bold;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>SVD in Color Space</h1>

        <div class="visualization-container">
            <div class="matrix-section">
                <div class="matrix-title">A</div>
                <div class="matrix-subtitle">Original [100×100×3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="originalImage" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">U</div>
                <div class="matrix-subtitle">Spatial Activations [10,000 × 3]</div>
                <div class="matrix-canvas-container">
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <div style="text-align: center;">
                            <canvas id="uMatrix0" width="120" height="120"></canvas>
                            <div id="uLabel0" class="u-column-label">
                                U<sub>:,1</sub></div>
                            <div id="uShapeInfo0" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix1" width="120" height="120"></canvas>
                            <div id="uLabel1" class="u-column-label">
                                U<sub>:,2</sub></div>
                            <div id="uShapeInfo1" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix2" width="120" height="120"></canvas>
                            <div id="uLabel2" class="u-column-label">
                                U<sub>:,3</sub></div>
                            <div id="uShapeInfo2" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">Σ</div>
                <div class="matrix-subtitle">Importance Weights [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="sigmaMatrix" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">V<sup>T</sup></div>
                <div class="matrix-subtitle">Principal Color Axes [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="vMatrix" width="200" height="200"></canvas>
                </div>
            </div>
        </div>

        <div class="equation">
            A<sub>f</sub> = U × Σ × V<sup>T</sup> &nbsp;&nbsp;
        </div>
        <div class="flattening-note">
            A [100×100×3] → A<sub>f</sub> [10000×3]
        </div>

        <div class="controls">
            <div class="slider-container">
                <div class="slider-group" id="colorSliderGroup">
                    <label for="colorSlider">Colors: <span class="slider-value" id="colorValue">3</span></label>
                    <input type="range" id="colorSlider" class="slider" min="1" max="10" value="3"
                        oninput="updateSliders()">
                </div>
                <div class="slider-group" id="shapeSliderGroup">
                    <label for="shapeSlider">Shapes: <span class="slider-value" id="shapeValue">3</span></label>
                    <input type="range" id="shapeSlider" class="slider" min="1" max="10" value="3"
                        oninput="updateSliders()">
                </div>
                <div class="slider-group" id="rankSliderGroup">
                    <label for="rankSlider">Rank: <span class="slider-value" id="rankValue">3</span></label>
                    <input type="range" id="rankSlider" class="slider" min="0" max="3" value="3"
                        oninput="updateRankSlider()">
                </div>
            </div>
        </div>
    </div>

    <script>

        // Image dimensions
        const imageSize = 100;
        const canvasSize = 200;

        // Current image data
        let currentImageData = null;
        let currentSVD = null;
        let currentColorComplexity = 3;
        let currentShapeComplexity = 3;
        let currentRank = 3; // Current rank for approximation
        let isRankSliderActive = false; // Track if rank slider is being actively used
        let fixedShapes = null; // Store consistent shape positions and types

        // Initialize the visualization
        function init() {
            // Generate initial fixed shapes
            fixedShapes = generateShapes(currentShapeComplexity, []); // Empty colors initially
            generateComplexImage(currentColorComplexity, currentShapeComplexity);
            performSVD();

            // Set initial rank to match the actual rank and update slider limits
            updateRankSliderLimits();
            currentRank = Math.min(currentColorComplexity, 3);
            document.getElementById('rankSlider').value = currentRank;
            document.getElementById('rankValue').textContent = currentRank;

            // Set up rank slider interaction listeners
            setupRankSliderInteraction();

            drawAll();
        }

        // Update rank slider limits based on current color complexity
        function updateRankSliderLimits() {
            const actualRank = Math.min(currentColorComplexity, 3);
            const rankSlider = document.getElementById('rankSlider');

            // Update max value to match actual rank
            rankSlider.max = actualRank;

            // If current rank is higher than the new max, adjust it
            if (currentRank > actualRank) {
                currentRank = actualRank;
                rankSlider.value = currentRank;
                document.getElementById('rankValue').textContent = currentRank;
            }
        }

        // Set up rank slider interaction detection
        function setupRankSliderInteraction() {
            const rankSlider = document.getElementById('rankSlider');

            // Mouse events
            rankSlider.addEventListener('mousedown', () => {
                isRankSliderActive = true;
                // Immediately show highlighting when user starts dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('mouseup', () => {
                isRankSliderActive = false;
                // Hide highlighting when user stops dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            // Touch events for mobile
            rankSlider.addEventListener('touchstart', () => {
                isRankSliderActive = true;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('touchend', () => {
                isRankSliderActive = false;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });
        }

        // Update slider values and regenerate image
        function updateSliders() {
            const newColorComplexity = parseInt(document.getElementById('colorSlider').value);
            const newShapeComplexity = parseInt(document.getElementById('shapeSlider').value);

            // Auto-adjust logic: ensure we have enough shapes to support the color complexity
            let adjustedColorComplexity = newColorComplexity;
            let adjustedShapeComplexity = newShapeComplexity;

            // If user increases color complexity beyond shape complexity, increase shapes too
            if (newColorComplexity > currentShapeComplexity && newColorComplexity !== currentColorComplexity) {
                adjustedShapeComplexity = Math.max(newShapeComplexity, newColorComplexity);
                document.getElementById('shapeSlider').value = adjustedShapeComplexity;
                document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('shapeSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('shapeSliderGroup').classList.remove('slider-auto-adjusted');
                }, 500);

                // Show brief notification
                showSliderNotification(`Shape complexity automatically increased to ${adjustedShapeComplexity} to support ${newColorComplexity} colors`);
            }

            // If user decreases shape complexity below color complexity, decrease colors too
            if (newShapeComplexity < currentColorComplexity && newShapeComplexity !== currentShapeComplexity) {
                adjustedColorComplexity = Math.min(newColorComplexity, newShapeComplexity);
                document.getElementById('colorSlider').value = adjustedColorComplexity;
                document.getElementById('colorValue').textContent = adjustedColorComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('colorSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('colorSliderGroup').classList.remove('slider-auto-adjusted');
                }, 500);

                // Show brief notification
                showSliderNotification(`Color complexity automatically decreased to ${adjustedColorComplexity} to match ${newShapeComplexity} shapes`);
            }

            // Update display values
            document.getElementById('colorValue').textContent = adjustedColorComplexity;
            document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

            // Add or remove shapes if shape complexity changed
            if (adjustedShapeComplexity !== currentShapeComplexity) {
                if (adjustedShapeComplexity > currentShapeComplexity) {
                    addShapesToPattern(adjustedShapeComplexity - currentShapeComplexity);
                }
            }

            currentColorComplexity = adjustedColorComplexity;
            currentShapeComplexity = adjustedShapeComplexity;

            generateComplexImage(currentColorComplexity, currentShapeComplexity);
            performSVD();

            // Update rank slider limits and preserve current rank if still valid
            updateRankSliderLimits();

            drawAll();
        }

        // Update rank slider and display approximation
        function updateRankSlider() {
            const newRank = parseInt(document.getElementById('rankSlider').value);
            currentRank = newRank;

            // Update display value
            document.getElementById('rankValue').textContent = currentRank;

            // Update the title based on rank
            updateImageTitle();

            // Redraw with current highlighting state (depends on isRankSliderActive)
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateULabels();
        }        // Briefly highlight all components at full rank, then fade to default

        function updateImageTitle() {
            const subtitleElement = document.querySelector('.matrix-subtitle');
            const actualRank = Math.min(currentColorComplexity, 3); // Actual rank of the image

            if (currentRank === actualRank) {
                subtitleElement.innerHTML = 'Original [100×100×3]';
            } else if (currentRank === 0) {
                subtitleElement.innerHTML = 'Zero [100×100×3]';
            } else {
                subtitleElement.innerHTML = `Rank-${currentRank} Approximation [100×100×3]`;
            }
        }

        // Add notification function
        function showSliderNotification(message) {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('sliderNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'sliderNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #007bff;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 10000;
                    font-size: 14px;
                    max-width: 400px;
                    text-align: center;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(notification);
            }

            // Show notification
            notification.textContent = message;
            notification.style.opacity = '1';

            // Hide after 2.5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2500);
        }

        function generateComplexImage(colorComplexity, shapeComplexity) {
            // Initialize image with background
            currentImageData = new Array(imageSize);
            for (let i = 0; i < imageSize; i++) {
                currentImageData[i] = new Array(imageSize);
                for (let j = 0; j < imageSize; j++) {
                    currentImageData[i][j] = [0, 0, 0]; // Black background
                }
            }

            // Generate color palette based on complexity
            const colors = getColorPalette(colorComplexity);

            // Use fixed shapes but apply current colors
            const shapesToDraw = assignColorsToFixedShapes(fixedShapes, colors, shapeComplexity);

            // Draw shapes to the image
            drawShapes(shapesToDraw);
        }

        function assignColorsToFixedShapes(shapes, colors, shapeComplexity) {
            // Take only the number of shapes we want based on current complexity
            const activeShapes = shapes.slice(0, Math.min(shapeComplexity, shapes.length));

            // Always reassign colors cyclically to ensure color changes are reflected
            // This ensures that when color complexity changes, all shapes get new color assignments
            const shapesWithColors = activeShapes.map((shape, index) => {
                const assignedColor = colors.length > 0 ? colors[index % colors.length] : [255, 255, 255];
                return {
                    ...shape,
                    color: assignedColor
                };
            });

            return shapesWithColors;
        }

        function getColorPalette(complexity) {
            const baseColors = [
                [255, 0, 0],    // Red
                [0, 255, 0],    // Green  
                [0, 0, 255],    // Blue
                [255, 255, 0],  // Yellow
                [255, 0, 255],  // Magenta
                [0, 255, 255],  // Cyan
                [255, 128, 0],  // Orange
                [128, 0, 255],  // Purple
                [255, 192, 203], // Pink
                [128, 255, 0]   // Lime
            ];

            return baseColors.slice(0, Math.min(complexity, baseColors.length));
        }

        function generateShapes(complexity, colors) {
            const shapes = [];
            const shapeTypes = ['circle', 'rectangle', 'triangle', 'diamond', 'pentagon', 'hexagon', 'star', 'ellipse', 'cross', 'heart'];

            // Generate up to 10 shapes with fixed positions but no colors yet
            for (let i = 0; i < Math.min(10, 10); i++) { // Always generate 10 potential shapes
                const shapeType = shapeTypes[i % shapeTypes.length];

                shapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }

            return shapes;
        }

        function addShapesToPattern(numNewShapes) {
            const shapeTypes = ['circle', 'rectangle', 'triangle', 'diamond', 'pentagon', 'hexagon', 'star', 'ellipse', 'cross', 'heart'];

            // Add new shapes to the existing pattern
            for (let i = 0; i < numNewShapes && fixedShapes.length < 10; i++) {
                const currentShapeIndex = fixedShapes.length;
                const shapeType = shapeTypes[currentShapeIndex % shapeTypes.length];

                fixedShapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }
        }

        function drawShapes(shapes) {
            shapes.forEach(shape => {
                switch (shape.type) {
                    case 'circle':
                        drawCircle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'rectangle':
                        drawRectangle(shape.x, shape.y, shape.size, shape.size, shape.color);
                        break;
                    case 'triangle':
                        drawTriangle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'diamond':
                        drawDiamond(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'pentagon':
                        drawPolygon(shape.x, shape.y, shape.size, 5, shape.color, shape.rotation);
                        break;
                    case 'hexagon':
                        drawPolygon(shape.x, shape.y, shape.size, 6, shape.color, shape.rotation);
                        break;
                    case 'star':
                        drawStar(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'ellipse':
                        drawEllipse(shape.x, shape.y, shape.size, shape.size * 0.7, shape.color);
                        break;
                    case 'cross':
                        drawCross(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'heart':
                        drawHeart(shape.x, shape.y, shape.size, shape.color);
                        break;
                }
            });
        }

        function drawCircle(cx, cy, radius, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dist = Math.sqrt((i - cy) ** 2 + (j - cx) ** 2);
                    if (dist <= radius) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawRectangle(x, y, width, height, color) {
            for (let i = Math.max(0, Math.floor(y)); i < Math.min(imageSize, Math.ceil(y + height)); i++) {
                for (let j = Math.max(0, Math.floor(x)); j < Math.min(imageSize, Math.ceil(x + width)); j++) {
                    if (i >= 0 && i < imageSize && j >= 0 && j < imageSize) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawTriangle(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Simple right triangle
                    const relativeI = i - cy;
                    const relativeJ = j - cx;
                    if (relativeJ >= 0 && relativeI >= 0 && relativeJ < (size - relativeI) && relativeI < size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawDiamond(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = Math.abs(j - cx);
                    const dy = Math.abs(i - cy);
                    if (dx + dy <= size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawPolygon(cx, cy, size, sides, color, rotation) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx) + rotation;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Approximate polygon as circle for simplicity
                    const polygonRadius = size * Math.cos(Math.PI / sides) / Math.cos((angle % (2 * Math.PI / sides)) - Math.PI / sides);
                    if (dist <= Math.abs(polygonRadius) && dist <= size) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawStar(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Simple 5-pointed star approximation
                    const starAngle = ((angle + Math.PI) % (2 * Math.PI / 5)) - Math.PI / 5;
                    const starRadius = size * (0.5 + 0.5 * Math.cos(5 * starAngle));
                    if (dist <= starRadius) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawEllipse(cx, cy, width, height, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / width;
                    const dy = (i - cy) / height;
                    if (dx * dx + dy * dy <= 1) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function drawCross(cx, cy, size, color) {
            const thickness = Math.max(3, Math.floor(size / 4));
            // Horizontal bar
            const hx = Math.floor(cx - size);
            const hy = Math.floor(cy - thickness / 2);
            const hwidth = Math.floor(size * 2);
            const hheight = Math.floor(thickness);
            drawRectangle(hx, hy, hwidth, hheight, color);

            // Vertical bar  
            const vx = Math.floor(cx - thickness / 2);
            const vy = Math.floor(cy - size);
            const vwidth = Math.floor(thickness);
            const vheight = Math.floor(size * 2);
            drawRectangle(vx, vy, vwidth, vheight, color);
        }

        function drawHeart(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / size;
                    const dy = (i - cy) / size;

                    // Heart equation approximation
                    const heartEq = Math.pow(dx * dx + dy * dy - 1, 3) - dx * dx * dy * dy * dy;
                    if (heartEq <= 0 && dx * dx + dy * dy <= 2) {
                        currentImageData[i][j] = color;
                    }
                }
            }
        }

        function performSVD() {
            // Convert the 3D image array (100x100x3) into a 2D matrix (10000x3)
            // Each row represents a pixel with its RGB values
            const imageMatrix = [];
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Normalize to 0-1 range for better numerical stability
                    const [r, g, b] = currentImageData[i][j];
                    imageMatrix.push([r / 255, g / 255, b / 255]);
                }
            }

            // Perform actual SVD from scratch
            currentSVD = computeSVDFromScratch(imageMatrix);

            console.log(currentSVD);
        }



        function computeSVDFromScratch(matrix) {
            let A = new mlMatrix.Matrix(matrix);

            // Perform SVD
            const svd = new mlMatrix.SingularValueDecomposition(A);

            // Extract components
            const U = svd.leftSingularVectors.to2DArray();
            const sigma = svd.diagonal;
            const V = svd.rightSingularVectors.to2DArray();

            // Transpose V to get V^T (ML-Matrix returns V, but we need V^T)
            const VT = [];
            for (let i = 0; i < V[0].length; i++) {
                VT[i] = [];
                for (let j = 0; j < V.length; j++) {
                    VT[i][j] = V[j][i];
                }
            }

            // Fix sign ambiguity: make the largest absolute value in each V^T row positive
            for (let i = 0; i < VT.length; i++) {
                const row = VT[i];
                let maxAbsIdx = 0;
                let maxAbsVal = Math.abs(row[0]);

                for (let j = 1; j < row.length; j++) {
                    if (Math.abs(row[j]) > maxAbsVal) {
                        maxAbsVal = Math.abs(row[j]);
                        maxAbsIdx = j;
                    }
                }

                // If the largest element is negative, flip the sign of the entire row
                // and corresponding column in U
                if (row[maxAbsIdx] < 0) {
                    for (let j = 0; j < row.length; j++) {
                        VT[i][j] = -VT[i][j];
                    }
                    for (let k = 0; k < U.length; k++) {
                        U[k][i] = -U[k][i];
                    }
                }
            }

            return { U, sigma, VT };
        }

        function drawAll() {
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateImageTitle();
        }

        function drawOriginalImageWithRank() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvasSize, canvasSize);

            if (currentRank === 0) {
                // Black image for rank 0
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = 0;     // Red
                    imageData.data[i + 1] = 0; // Green
                    imageData.data[i + 2] = 0; // Blue
                    imageData.data[i + 3] = 255; // Alpha
                }
            } else {
                // Compute rank-k approximation
                for (let i = 0; i < canvasSize; i++) {
                    for (let j = 0; j < canvasSize; j++) {
                        // Map canvas coordinates to image coordinates
                        const imgI = Math.floor(i * imageSize / canvasSize);
                        const imgJ = Math.floor(j * imageSize / canvasSize);
                        const flatIndex = imgI * imageSize + imgJ;

                        // Compute rank-k approximation: sum of first k rank-1 components
                        let r = 0, g = 0, b = 0;
                        for (let k = 0; k < currentRank; k++) {
                            const sigma = currentSVD.sigma[k];
                            const u_val = currentSVD.U[flatIndex][k];
                            const v_r = currentSVD.VT[k][0];
                            const v_g = currentSVD.VT[k][1];
                            const v_b = currentSVD.VT[k][2];

                            r += u_val * sigma * v_r;
                            g += u_val * sigma * v_g;
                            b += u_val * sigma * v_b;
                        }

                        // Scale and clamp to [0, 255]
                        r = Math.max(0, Math.min(255, r * 255));
                        g = Math.max(0, Math.min(255, g * 255));
                        b = Math.max(0, Math.min(255, b * 255));

                        const pixelIndex = (i * canvasSize + j) * 4;
                        imageData.data[pixelIndex] = r;     // Red
                        imageData.data[pixelIndex + 1] = g; // Green
                        imageData.data[pixelIndex + 2] = b; // Blue
                        imageData.data[pixelIndex + 3] = 255; // Alpha
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Setup hover interaction for original image A
            setupOriginalImageInteraction();
        }

        function setupOriginalImageInteraction() {
            const canvas = document.getElementById('originalImage');

            // Remove existing listeners to prevent duplicates
            canvas.onmouseenter = null;
            canvas.onmouseleave = null;

            canvas.onmouseenter = function () {
                if (!hoveredOriginalImage) {
                    hoveredOriginalImage = true;
                    drawRGBChannelsInMainMatrices();
                }
            };

            canvas.onmousemove = function (event) {
                if (hoveredOriginalImage) {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;

                    // Convert canvas coordinates to image coordinates
                    const imgX = Math.floor(x * imageSize / canvasSize);
                    const imgY = Math.floor(y * imageSize / canvasSize);

                    // Get the RGB values at this position
                    if (imgX >= 0 && imgX < imageSize && imgY >= 0 && imgY < imageSize) {
                        const [r, g, b] = currentImageData[imgY][imgX];
                        drawRGBChannelsWithHighlight(imgX, imgY, r, g, b);
                    }
                }
            };

            canvas.onmouseleave = function () {
                if (hoveredOriginalImage) {
                    hoveredOriginalImage = false;

                    // Restore U matrix display
                    const uMatrixContainer = document.querySelector('.matrix-section:nth-child(2) .matrix-canvas-container');
                    const originalUDisplay = uMatrixContainer.querySelector('div[style*="display: flex"], div[style*="display: none"]');
                    if (originalUDisplay) {
                        originalUDisplay.style.display = 'flex';
                    }

                    // Hide the red overlay canvas
                    const redOverlayCanvas = document.getElementById('redOverlayCanvas');
                    if (redOverlayCanvas) {
                        redOverlayCanvas.style.display = 'none';
                    }

                    // Restore original titles and subtitles
                    const mainTitle = document.querySelector('h1');
                    mainTitle.textContent = 'SVD in Color Space';

                    // Restore original SVD equation
                    const equation = document.querySelector('.equation');
                    if (equation) {
                        equation.innerHTML = 'A<sub>f</sub> = U × Σ × V<sup>T</sup> &nbsp;&nbsp;';
                    }

                    const uTitle = document.querySelector('.matrix-section:nth-child(2) .matrix-title');
                    const uSubtitle = document.querySelector('.matrix-section:nth-child(2) .matrix-subtitle');
                    const sigmaTitle = document.querySelector('.matrix-section:nth-child(3) .matrix-title');
                    const sigmaSubtitle = document.querySelector('.matrix-section:nth-child(3) .matrix-subtitle');
                    const vTitle = document.querySelector('.matrix-section:nth-child(4) .matrix-title');
                    const vSubtitle = document.querySelector('.matrix-section:nth-child(4) .matrix-subtitle');

                    uTitle.innerHTML = 'U';
                    uTitle.style.color = '';
                    uSubtitle.innerHTML = 'Spatial Activations [10,000 × 3]';

                    sigmaTitle.innerHTML = 'Σ';
                    sigmaTitle.style.color = '';
                    sigmaSubtitle.innerHTML = 'Importance Weights [3 x 3]';

                    vTitle.innerHTML = 'V<sup>T</sup>';
                    vTitle.style.color = '';
                    vSubtitle.innerHTML = 'Principal Color Axes [3 x 3]';

                    // Remove RGB mode class for mobile
                    document.body.classList.remove('rgb-mode');

                    // Clear RGB highlighting state
                    window.rgbHighlightRows = null;

                    // Restore original matrices
                    drawUMatrix();
                    drawSigmaMatrix();
                    drawVMatrix();
                    updateULabels();
                }
            };
        }

        function drawRGBChannelsInMainMatrices() {
            // Update main page title
            const mainTitle = document.querySelector('h1');
            mainTitle.textContent = 'RGB Channel Decomposition';

            // Change equation to show RGB identity decomposition
            const equation = document.querySelector('.equation');
            if (equation) {
                equation.innerHTML = 'A<sub>f</sub> = A<sub>f</sub> × I &nbsp;&nbsp;';
            }

            // Show the individual U column matrices and draw RGB channels in them
            const uMatrixContainer = document.querySelector('.matrix-section:nth-child(2) .matrix-canvas-container');

            // Make sure the original U matrix display is visible
            const originalUDisplay = uMatrixContainer.querySelector('div[style*="display: flex"], div[style*="display: none"]');
            if (originalUDisplay) {
                originalUDisplay.style.display = 'flex';
            }

            // Hide any existing red overlay canvas
            const redOverlayCanvas = document.getElementById('redOverlayCanvas');
            if (redOverlayCanvas) {
                redOverlayCanvas.style.display = 'none';
            }

            // Draw Red channel in first U column (uMatrix0)
            const redCanvas = document.getElementById('uMatrix0');
            const redCtx = redCanvas.getContext('2d');
            const redImageData = redCtx.createImageData(120, 120);

            // Draw Green channel in second U column (uMatrix1)
            const greenCanvas = document.getElementById('uMatrix1');
            const greenCtx = greenCanvas.getContext('2d');
            const greenImageData = greenCtx.createImageData(120, 120);

            // Draw Blue channel in third U column (uMatrix2)
            const blueCanvas = document.getElementById('uMatrix2');
            const blueCtx = blueCanvas.getContext('2d');
            const blueImageData = blueCtx.createImageData(120, 120);

            for (let i = 0; i < 120; i++) {
                for (let j = 0; j < 120; j++) {
                    const imgI = Math.floor(i * imageSize / 120);
                    const imgJ = Math.floor(j * imageSize / 120);
                    const pixelIndex = (i * 120 + j) * 4;
                    const [r, g, b] = currentImageData[imgI][imgJ];

                    // Red channel (color-tinted)
                    redImageData.data[pixelIndex] = r;         // Red component
                    redImageData.data[pixelIndex + 1] = 0;     // No green
                    redImageData.data[pixelIndex + 2] = 0;     // No blue
                    redImageData.data[pixelIndex + 3] = 255;   // Alpha

                    // Green channel (color-tinted)
                    greenImageData.data[pixelIndex] = 0;       // No red
                    greenImageData.data[pixelIndex + 1] = g;   // Green component
                    greenImageData.data[pixelIndex + 2] = 0;   // No blue
                    greenImageData.data[pixelIndex + 3] = 255; // Alpha

                    // Blue channel (color-tinted)
                    blueImageData.data[pixelIndex] = 0;        // No red
                    blueImageData.data[pixelIndex + 1] = 0;    // No green
                    blueImageData.data[pixelIndex + 2] = b;    // Blue component
                    blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                }
            }

            redCtx.putImageData(redImageData, 0, 0);
            greenCtx.putImageData(greenImageData, 0, 0);
            blueCtx.putImageData(blueImageData, 0, 0);

            // Update U matrix labels to show RGB channels
            document.getElementById('uLabel0').innerHTML = 'A<sub>R</sub>';
            document.getElementById('uShapeInfo0').innerHTML = '→ [100 × 100]';
            document.getElementById('uLabel1').innerHTML = 'A<sub>G</sub>';
            document.getElementById('uShapeInfo1').innerHTML = '→ [100 × 100]';
            document.getElementById('uLabel2').innerHTML = 'A<sub>B</sub>';
            document.getElementById('uShapeInfo2').innerHTML = '→ [100 × 100]';

            // Update U matrix title and subtitle
            const uTitle = document.querySelector('.matrix-section:nth-child(2) .matrix-title');
            const uSubtitle = document.querySelector('.matrix-section:nth-child(2) .matrix-subtitle');
            uTitle.innerHTML = 'A<sub>f</sub>';
            uTitle.style.color = '#333';
            uSubtitle.innerHTML = 'Channel Activations [10,000 x 3]';

            // Calculate variance squared for each color channel
            const sigmaCanvas = document.getElementById('sigmaMatrix');
            const sigmaCtx = sigmaCanvas.getContext('2d');

            // Clear canvas with white background (same as original)
            sigmaCtx.fillStyle = 'white';
            sigmaCtx.fillRect(0, 0, 200, 200);

            // Calculate variance for each channel across all pixels
            let redSum = 0, greenSum = 0, blueSum = 0;
            let redSumSq = 0, greenSumSq = 0, blueSumSq = 0;
            const totalPixels = imageSize * imageSize;

            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const [r, g, b] = currentImageData[i][j];

                    redSum += r;
                    greenSum += g;
                    blueSum += b;

                    redSumSq += r * r;
                    greenSumSq += g * g;
                    blueSumSq += b * b;
                }
            }

            // Calculate variance = E[X²] - (E[X])²
            const redMean = redSum / totalPixels;
            const greenMean = greenSum / totalPixels;
            const blueMean = blueSum / totalPixels;

            const redVariance = (redSumSq / totalPixels) - (redMean * redMean);
            const greenVariance = (greenSumSq / totalPixels) - (greenMean * greenMean);
            const blueVariance = (blueSumSq / totalPixels) - (blueMean * blueMean);

            // Take square root to get standard deviation (analogous to singular values)
            const redStdDev = Math.sqrt(redVariance);
            const greenStdDev = Math.sqrt(greenVariance);
            const blueStdDev = Math.sqrt(blueVariance);

            // Use same drawing style as original sigma matrix
            const stdDevs = [redStdDev, greenStdDev, blueStdDev];
            const colors = ['#e74c3c', '#27ae60', '#3498db'];
            const labels = ['R', 'G', 'B'];

            const maxStdDev = Math.max(...stdDevs);
            const barWidth = 200 / stdDevs.length;
            const margin = 20;

            for (let i = 0; i < stdDevs.length; i++) {
                const height = ((stdDevs[i] / maxStdDev) * (200 - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = 200 - margin - height;
                const w = barWidth * 0.8;

                // Use channel colors instead of blue/gray
                sigmaCtx.fillStyle = colors[i];
                sigmaCtx.fillRect(x, y, w, height);

                // Add value label (same style as original)
                sigmaCtx.fillStyle = 'black';
                sigmaCtx.font = '12px Arial';
                sigmaCtx.textAlign = 'center';
                sigmaCtx.fillText(stdDevs[i].toFixed(1), i * barWidth + barWidth / 2, 200 - 5);
                sigmaCtx.fillText(`σ${labels[i]}`, i * barWidth + barWidth / 2, y - 5);
            }

            // Temporarily replace currentSVD.VT with RGB identity matrix and reuse drawVMatrix()
            const originalVT = currentSVD.VT;

            // Set RGB identity matrix: [1,0,0], [0,1,0], [0,0,1]
            currentSVD.VT = [
                [1, 0, 0], // Red row
                [0, 1, 0], // Green row  
                [0, 0, 1]  // Blue row
            ];

            // Call the existing drawVMatrix function to maintain consistent styling
            drawVMatrix();

            // Restore original VT matrix
            currentSVD.VT = originalVT;

            // Update Sigma matrix title and subtitle
            const sigmaTitle = document.querySelector('.matrix-section:nth-child(3) .matrix-title');
            const sigmaSubtitle = document.querySelector('.matrix-section:nth-child(3) .matrix-subtitle');
            sigmaTitle.innerHTML = 'Σ<sub>RGB</sub>';
            sigmaTitle.style.color = '#333';
            sigmaSubtitle.innerHTML = 'Standard Deviation [R, G, B]';

            // Update V^T matrix title and subtitle
            const vTitle = document.querySelector('.matrix-section:nth-child(4) .matrix-title');
            const vSubtitle = document.querySelector('.matrix-section:nth-child(4) .matrix-subtitle');
            vTitle.innerHTML = 'I';
            vTitle.style.color = '#333';
            vSubtitle.innerHTML = 'RGB Color Axes [3 x 3]';

            // Add special class for mobile RGB display
            document.body.classList.add('rgb-mode');
        }

        function drawRGBChannelsWithHighlight(hoverX, hoverY, hoverR, hoverG, hoverB) {
            // Determine which channels have significant contribution (non-zero or above threshold)
            const threshold = 10; // Minimum value to consider "contributing"
            const redActive = hoverR > threshold;
            const greenActive = hoverG > threshold;
            const blueActive = hoverB > threshold;

            // Draw Red channel in first U column (uMatrix0) with conditional highlighting
            const redCanvas = document.getElementById('uMatrix0');
            const redCtx = redCanvas.getContext('2d');
            const redImageData = redCtx.createImageData(120, 120);

            // Draw Green channel in second U column (uMatrix1) with conditional highlighting
            const greenCanvas = document.getElementById('uMatrix1');
            const greenCtx = greenCanvas.getContext('2d');
            const greenImageData = greenCtx.createImageData(120, 120);

            // Draw Blue channel in third U column (uMatrix2) with conditional highlighting
            const blueCanvas = document.getElementById('uMatrix2');
            const blueCtx = blueCanvas.getContext('2d');
            const blueImageData = blueCtx.createImageData(120, 120);

            for (let i = 0; i < 120; i++) {
                for (let j = 0; j < 120; j++) {
                    const imgI = Math.floor(i * imageSize / 120);
                    const imgJ = Math.floor(j * imageSize / 120);
                    const pixelIndex = (i * 120 + j) * 4;
                    const [r, g, b] = currentImageData[imgI][imgJ];

                    // Red channel with conditional highlighting
                    if (redActive) {
                        // Full red channel display
                        redImageData.data[pixelIndex] = r;         // Red component
                        redImageData.data[pixelIndex + 1] = 0;     // No green
                        redImageData.data[pixelIndex + 2] = 0;     // No blue
                        redImageData.data[pixelIndex + 3] = 255;   // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        redImageData.data[pixelIndex] = r;         // Red = intensity
                        redImageData.data[pixelIndex + 1] = r;     // Green = intensity
                        redImageData.data[pixelIndex + 2] = r;     // Blue = intensity
                        redImageData.data[pixelIndex + 3] = 255;   // Alpha
                    }

                    // Green channel with conditional highlighting
                    if (greenActive) {
                        // Full green channel display
                        greenImageData.data[pixelIndex] = 0;       // No red
                        greenImageData.data[pixelIndex + 1] = g;   // Green component
                        greenImageData.data[pixelIndex + 2] = 0;   // No blue
                        greenImageData.data[pixelIndex + 3] = 255; // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        greenImageData.data[pixelIndex] = g;       // Red = intensity
                        greenImageData.data[pixelIndex + 1] = g;   // Green = intensity
                        greenImageData.data[pixelIndex + 2] = g;   // Blue = intensity
                        greenImageData.data[pixelIndex + 3] = 255; // Alpha
                    }

                    // Blue channel with conditional highlighting
                    if (blueActive) {
                        // Full blue channel display
                        blueImageData.data[pixelIndex] = 0;        // No red
                        blueImageData.data[pixelIndex + 1] = 0;    // No green
                        blueImageData.data[pixelIndex + 2] = b;    // Blue component
                        blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        blueImageData.data[pixelIndex] = b;        // Red = intensity
                        blueImageData.data[pixelIndex + 1] = b;    // Green = intensity
                        blueImageData.data[pixelIndex + 2] = b;    // Blue = intensity
                        blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                    }
                }
            }

            redCtx.putImageData(redImageData, 0, 0);
            greenCtx.putImageData(greenImageData, 0, 0);
            blueCtx.putImageData(blueImageData, 0, 0);

            // Add highlight cursors at hover position for active channels
            const cursorX = hoverX * 120 / imageSize;
            const cursorY = hoverY * 120 / imageSize;

            if (redActive) {
                redCtx.strokeStyle = '#fff';
                redCtx.lineWidth = 2;
                redCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            if (greenActive) {
                greenCtx.strokeStyle = '#fff';
                greenCtx.lineWidth = 2;
                greenCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            if (blueActive) {
                blueCtx.strokeStyle = '#fff';
                blueCtx.lineWidth = 2;
                blueCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            // Update labels to show current pixel values and activity status
            const redLabel = document.getElementById('uLabel0');
            const greenLabel = document.getElementById('uLabel1');
            const blueLabel = document.getElementById('uLabel2');

            // Also update shape info
            const redShapeInfo = document.getElementById('uShapeInfo0');
            const greenShapeInfo = document.getElementById('uShapeInfo1');
            const blueShapeInfo = document.getElementById('uShapeInfo2');

            // Calculate dynamic colors based on RGB identity matrix (same as sigma bars)
            const rgbIdentityRows = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
            const labels = [redLabel, greenLabel, blueLabel];
            const shapeInfos = [redShapeInfo, greenShapeInfo, blueShapeInfo];
            const activeStates = [redActive, greenActive, blueActive];
            const values = [hoverR, hoverG, hoverB];
            const subscripts = ['R', 'G', 'B'];

            for (let i = 0; i < 3; i++) {

                let labelColor = '#333';
                let shapeInfoColor = '#666';
                if (activeStates[i]) {
                    const row = rgbIdentityRows[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    let r = Math.floor((rVal / maxVal) * 255);
                    let g = Math.floor((gVal / maxVal) * 255);
                    let b = Math.floor((bVal / maxVal) * 255);

                    // Calculate luminance using standard formula
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                    // If the color is too light (luminance > 127), darken it for better contrast
                    if (luminance > 127) {
                        // Darken more aggressively by reducing all components proportionally
                        const darkenFactor = 0.7;
                        r = Math.floor(r * darkenFactor);
                        g = Math.floor(g * darkenFactor);
                        b = Math.floor(b * darkenFactor);
                    }

                    labelColor = `rgb(${r}, ${g}, ${b})`;

                    labels[i].innerHTML = `a<sub>f${i + 1}</sub>e<sub>${i + 1}</sub><sup>T</sup>`;
                    shapeInfos[i].innerHTML = `[100 × 100 x 3]`;
                    shapeInfos[i].style.color = labelColor;
                }
                else {
                    labels[i].innerHTML = `A<sub>f [:,${i + 1}]</sub>`;
                    shapeInfos[i].innerHTML = '→ [100 × 100]';
                    shapeInfos[i].style.color = shapeInfoColor;
                }
                labels[i].style.color = labelColor;
            }

            // Update sigma bars with highlighting based on active channels
            drawRGBSigmaWithHighlight(redActive, greenActive, blueActive, hoverR, hoverG, hoverB);

            // Update V^T matrix with highlighting based on active channels
            // Save the original hoveredVTRow state
            const originalHoveredVTRow = hoveredVTRow;

            // Set highlighting based on which color channels are active
            // Since hoveredVTRow can only highlight one row at a time, we need a different approach
            // Let's create a custom highlighting system for multiple rows
            window.rgbHighlightRows = {
                red: redActive,
                green: greenActive,
                blue: blueActive
            };

            // For now, set hoveredVTRow to -1 and modify drawVMatrix to check our custom highlighting
            hoveredVTRow = -1;

            // Draw V^T matrix with RGB identity and highlighting
            const originalVT = currentSVD.VT;
            currentSVD.VT = [
                [1, 0, 0], // Red row
                [0, 1, 0], // Green row  
                [0, 0, 1]  // Blue row
            ];
            drawVMatrix();
            currentSVD.VT = originalVT;

            // Restore original hoveredVTRow state
            hoveredVTRow = originalHoveredVTRow;
        }

        function drawRGBSigmaWithHighlight(redActive, greenActive, blueActive, hoverR, hoverG, hoverB) {
            // Get the sigma canvas and recalculate the RGB standard deviations
            const sigmaCanvas = document.getElementById('sigmaMatrix');
            const sigmaCtx = sigmaCanvas.getContext('2d');

            // Clear canvas with white background
            sigmaCtx.fillStyle = 'white';
            sigmaCtx.fillRect(0, 0, 200, 200);

            // Recalculate RGB standard deviations (same as in drawRGBChannelsInMainMatrices)
            let redSum = 0, greenSum = 0, blueSum = 0;
            let redSumSq = 0, greenSumSq = 0, blueSumSq = 0;
            const totalPixels = imageSize * imageSize;

            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const [r, g, b] = currentImageData[i][j];

                    redSum += r;
                    greenSum += g;
                    blueSum += b;

                    redSumSq += r * r;
                    greenSumSq += g * g;
                    blueSumSq += b * b;
                }
            }

            const redMean = redSum / totalPixels;
            const greenMean = greenSum / totalPixels;
            const blueMean = blueSum / totalPixels;

            const redVariance = (redSumSq / totalPixels) - (redMean * redMean);
            const greenVariance = (greenSumSq / totalPixels) - (greenMean * greenMean);
            const blueVariance = (blueSumSq / totalPixels) - (blueMean * blueMean);

            const redStdDev = Math.sqrt(redVariance);
            const greenStdDev = Math.sqrt(greenVariance);
            const blueStdDev = Math.sqrt(blueVariance);

            const stdDevs = [redStdDev, greenStdDev, blueStdDev];
            const activeStates = [redActive, greenActive, blueActive];
            const labels = ['R', 'G', 'B'];

            const maxStdDev = Math.max(...stdDevs);
            const barWidth = 200 / stdDevs.length;
            const margin = 20;

            for (let i = 0; i < stdDevs.length; i++) {
                const height = ((stdDevs[i] / maxStdDev) * (200 - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = 200 - margin - height;
                const w = barWidth * 0.8;

                // Calculate dynamic color based on RGB identity matrix (same approach as SVD sigma bars)
                let barColor = '#999'; // Default gray
                if (activeStates[i]) {
                    // For RGB mode, we use the RGB identity matrix rows: [1,0,0], [0,1,0], [0,0,1]
                    const rgbIdentityRows = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
                    const row = rgbIdentityRows[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    const r = Math.floor((rVal / maxVal) * 255);
                    const g = Math.floor((gVal / maxVal) * 255);
                    const b = Math.floor((bVal / maxVal) * 255);

                    barColor = `rgb(${r}, ${g}, ${b})`;
                }

                sigmaCtx.fillStyle = barColor;
                sigmaCtx.fillRect(x, y, w, height);

                // Add value label (same style as original)
                sigmaCtx.fillStyle = 'black';
                sigmaCtx.font = '12px Arial';
                sigmaCtx.textAlign = 'center';
                sigmaCtx.fillText(stdDevs[i].toFixed(1), i * barWidth + barWidth / 2, 200 - 5);
                sigmaCtx.fillText(`σ${labels[i]}`, i * barWidth + barWidth / 2, y - 5);
            }
        }

        let hoveredVTRow = -1; // Track which V^T row is being hovered
        let hoveredOriginalImage = false; // Track if hovering over original image A

        function updateULabels() {
            for (let i = 0; i < 3; i++) {
                const label = document.getElementById(`uLabel${i}`);
                const shapeInfo = document.getElementById(`uShapeInfo${i}`);
                const isActive = (hoveredVTRow === i) ||
                    (isRankSliderActive && i < currentRank) ||
                    (window.showFullRankHighlight && i < 3); if (isActive) {
                        // Calculate dynamic color based on V^T row (same as sigma bars)
                        const row = currentSVD.VT[i];
                        const rVal = Math.abs(row[0]);
                        const gVal = Math.abs(row[1]);
                        const bVal = Math.abs(row[2]);

                        // Normalize to 0-255 range for color display
                        const maxVal = Math.max(rVal, gVal, bVal);
                        let r = Math.floor((rVal / maxVal) * 255);
                        let g = Math.floor((gVal / maxVal) * 255);
                        let b = Math.floor((bVal / maxVal) * 255);

                        // Calculate luminance using standard formula
                        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                        // If the color is too light (luminance > 127), darken it for better contrast
                        if (luminance > 127) {
                            // Darken more aggressively by reducing all components proportionally
                            const darkenFactor = 0.7;
                            r = Math.floor(r * darkenFactor);
                            g = Math.floor(g * darkenFactor);
                            b = Math.floor(b * darkenFactor);
                        }

                        const dynamicColor = `rgb(${r}, ${g}, ${b})`;

                        label.innerHTML = `σ<sub>${i + 1}</sub>u<sub>${i + 1}</sub>v<sub>${i + 1}</sub><sup>T</sup>`;
                        label.style.color = dynamicColor;
                        shapeInfo.innerHTML = `[100 × 100 x 3]`;
                        shapeInfo.style.color = dynamicColor;
                    } else {
                    label.innerHTML = `U<sub>:,${i + 1}</sub>`;
                    label.style.color = '#333';
                    shapeInfo.innerHTML = `→ [100 × 100]`;
                    shapeInfo.style.color = '#666';
                }
            }
        }

        function drawUMatrix() {
            // Draw each U column as a separate square canvas
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);
                const ctx = canvas.getContext('2d');
                const canvasSize = 120; // Size of each individual canvas

                // Clear canvas
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // Find min/max for normalization for this column
                let minVal = Infinity, maxVal = -Infinity;
                for (let i = 0; i < currentSVD.U.length; i++) {
                    const val = currentSVD.U[i][col];
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                }

                // Determine if this column should be colored based on V^T hover or rank approximation
                const shouldColor = (hoveredVTRow === col) ||
                    (isRankSliderActive && col < currentRank) ||
                    (window.showFullRankHighlight && col < 3);                // Draw column as square heatmap (unsquished)
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const idx = i * imageSize + j;
                        const val = currentSVD.U[idx][col];

                        if (shouldColor) {
                            // Use the exact same calculation as rank-1 components
                            const sigma = currentSVD.sigma[col];
                            const vRow = currentSVD.VT[col];
                            const uValue = currentSVD.U[idx][col];

                            // Calculate u_i * sigma_i * v_i^T for this pixel (same as rank-1 components)
                            const r = Math.max(0, Math.min(255, uValue * sigma * vRow[0] * 255));
                            const g = Math.max(0, Math.min(255, uValue * sigma * vRow[1] * 255));
                            const b = Math.max(0, Math.min(255, uValue * sigma * vRow[2] * 255));

                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            // Default grayscale
                            const normalized = (val - minVal) / (maxVal - minVal);
                            const intensity = Math.floor(normalized * 255);
                            ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                        }

                        // Map to square canvas coordinates
                        const x = (j / imageSize) * canvasSize;
                        const y = (i / imageSize) * canvasSize;
                        const w = canvasSize / imageSize;
                        const h = canvasSize / imageSize;

                        ctx.fillRect(x, y, w + 1, h + 1);
                    }
                }
            }

            // Set up hover interactions for each U matrix canvas
            setupUMatrixInteraction();
        }

        function setupUMatrixInteraction() {
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);

                // Remove existing listeners to prevent duplicates
                canvas.onmouseover = null;
                canvas.onmouseleave = null;

                canvas.onmouseover = function () {
                    if (hoveredVTRow !== col) {
                        hoveredVTRow = col;
                        drawUMatrix(); // Redraw U matrix with coloring
                        drawSigmaMatrix(); // Redraw sigma matrix with coloring
                        drawVMatrix(); // Redraw V matrix with highlighting
                        updateULabels(); // Update labels to show principal component
                    }
                };

                canvas.onmouseleave = function () {
                    if (hoveredVTRow === col) {
                        hoveredVTRow = -1;
                        drawUMatrix(); // Redraw U matrix without coloring
                        drawSigmaMatrix(); // Redraw sigma matrix without coloring
                        drawVMatrix(); // Redraw V matrix without highlighting
                        updateULabels(); // Reset labels to original text
                    }
                };
            }
        }

        function drawSigmaMatrix() {
            const canvas = document.getElementById('sigmaMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // Draw singular values as bars
            const maxSigma = Math.max(...currentSVD.sigma);
            const barWidth = canvasSize / currentSVD.sigma.length;
            const margin = 20;

            for (let i = 0; i < currentSVD.sigma.length; i++) {
                const height = ((currentSVD.sigma[i] / maxSigma) * (canvasSize - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = canvasSize - margin - height;
                const w = barWidth * 0.8;

                // Calculate the color for this singular value based on corresponding V^T row
                let barColor = '#999'; // Default gray
                if ((hoveredVTRow === i) || (isRankSliderActive && i < currentRank) || (window.showFullRankHighlight && i < 3)) {
                    // Get the RGB values for this V^T row (how this component mixes colors)
                    const row = currentSVD.VT[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    const r = Math.floor((rVal / maxVal) * 255);
                    const g = Math.floor((gVal / maxVal) * 255);
                    const b = Math.floor((bVal / maxVal) * 255);

                    barColor = `rgb(${r}, ${g}, ${b})`;
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(x, y, w, height);

                // Add value label
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentSVD.sigma[i].toFixed(1), i * barWidth + barWidth / 2, canvasSize - 5);
                ctx.fillText(`σ${i + 1}`, i * barWidth + barWidth / 2, y - 5);
            }

            // Set up hover interactions for sigma matrix
            setupSigmaMatrixInteraction(canvas, barWidth);
        }

        function setupSigmaMatrixInteraction(canvas, barWidth) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;

                // Determine which bar is being hovered
                const col = Math.floor(x / barWidth);

                if (col >= 0 && col < 3 && col !== hoveredVTRow) {
                    hoveredVTRow = col;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (hoveredVTRow !== -1) {
                    hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        function drawVMatrix() {
            const canvas = document.getElementById('vMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const cellSize = canvasSize / 3;

            // Find global min/max for consistent coloring
            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i < currentSVD.VT.length; i++) {
                for (let j = 0; j < currentSVD.VT[i].length; j++) {
                    minVal = Math.min(minVal, currentSVD.VT[i][j]);
                    maxVal = Math.max(maxVal, currentSVD.VT[i][j]);
                }
            }

            // Calculate row colors first for consistent coloring
            const rowColors = [];
            const rowNames = [];

            for (let i = 0; i < 3; i++) {
                const row = currentSVD.VT[i];

                // Get the RGB values for this row (how this component mixes colors)
                const rVal = Math.abs(row[0]);
                const gVal = Math.abs(row[1]);
                const bVal = Math.abs(row[2]);

                // Normalize to 0-255 range for color display
                const maxVal = Math.max(rVal, gVal, bVal);
                const r = Math.floor((rVal / maxVal) * 255);
                const g = Math.floor((gVal / maxVal) * 255);
                const b = Math.floor((bVal / maxVal) * 255);

                // Create a lighter version of the color for background (add transparency effect)
                const lightRowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
                const rowColor = `rgb(${r}, ${g}, ${b})`;

                rowColors.push({ light: lightRowColor, full: rowColor });

                // Determine the dominant color name
                if (rVal > gVal && rVal > bVal) {
                    rowNames.push('Red');
                } else if (gVal > rVal && gVal > bVal) {
                    rowNames.push('Green');
                } else {
                    rowNames.push('Blue');
                }
            }

            // Draw matrix cells with colored row backgrounds
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const val = currentSVD.VT[i][j];

                    // Use the row's light color as background (no color changes)
                    ctx.fillStyle = rowColors[i].light;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Draw normal border for all cells
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Add value text (always black since we use light colors)
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        val.toFixed(3),
                        j * cellSize + cellSize / 2,
                        i * cellSize + cellSize / 2 + 5
                    );
                }
            }

            // Draw shadow box around hovered row or active rank components
            for (let i = 0; i < 3; i++) {
                // Check for RGB-specific highlighting when displaying RGB identity matrix
                const isRGBHighlighted = window.rgbHighlightRows &&
                    ((i === 0 && window.rgbHighlightRows.red) ||
                        (i === 1 && window.rgbHighlightRows.green) ||
                        (i === 2 && window.rgbHighlightRows.blue));

                const shouldHighlight = (hoveredVTRow === i) ||
                    (isRankSliderActive && i < currentRank) ||
                    (window.showFullRankHighlight && i < 3) ||
                    isRGBHighlighted; if (shouldHighlight) {
                        const rowY = i * cellSize;
                        const margin = 6; // Margin to keep shadow within canvas bounds

                        // Create shadow effect
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;

                        // Draw shadow box around the entire row, inset by margin
                        ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(margin, rowY + margin, canvasSize - 2 * margin, cellSize - 2 * margin);

                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
            }

            // Draw row labels with full color backgrounds
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';

            for (let i = 0; i < 3; i++) {
                // Draw colored background for the row label
                const labelX = -45;
                const labelY = i * cellSize + cellSize / 2 - 7;
                const labelWidth = 40;
                const labelHeight = 14;

                ctx.fillStyle = rowColors[i].full;
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

                // Draw contrasting text
                const r = parseInt(rowColors[i].full.match(/\d+/g)[0]);
                const g = parseInt(rowColors[i].full.match(/\d+/g)[1]);
                const b = parseInt(rowColors[i].full.match(/\d+/g)[2]);
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                ctx.fillStyle = brightness > 127 ? 'black' : 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(rowNames[i], labelX + labelWidth / 2, labelY + 10);
            }

            // Add mouse event listeners for hover interaction
            setupVMatrixInteraction(canvas, cellSize);
        }

        function setupVMatrixInteraction(canvas, cellSize) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Determine which row is being hovered
                const row = Math.floor(y / cellSize);

                if (row >= 0 && row < 3 && row !== hoveredVTRow) {
                    hoveredVTRow = row;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (hoveredVTRow !== -1) {
                    hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        init();
    </script>
</body>

</html>