<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD in Color Space</title>
    <link rel="icon" type="image/x-icon" href="./assets/svd-color-space.svg">
    <link rel="stylesheet" href="./stylesheets/svd-color-space.css">
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1/matrix.umd.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>SVD in Color Space</h1>

        <div class="visualization-container">
            <div class="matrix-section">
                <div class="matrix-title">A</div>
                <div class="matrix-subtitle">Original [100×100×3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="originalImage" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">U</div>
                <div class="matrix-subtitle">Spatial Activations [10,000 × 3]</div>
                <div class="matrix-canvas-container">
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <div style="text-align: center;">
                            <canvas id="uMatrix0" width="120" height="120"></canvas>
                            <div id="uLabel0" class="u-column-label">
                                U<sub>:,1</sub></div>
                            <div id="uShapeInfo0" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix1" width="120" height="120"></canvas>
                            <div id="uLabel1" class="u-column-label">
                                U<sub>:,2</sub></div>
                            <div id="uShapeInfo1" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                        <div style="text-align: center;">
                            <canvas id="uMatrix2" width="120" height="120"></canvas>
                            <div id="uLabel2" class="u-column-label">
                                U<sub>:,3</sub></div>
                            <div id="uShapeInfo2" class="u-column-info">
                                → [100 × 100]</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">Σ</div>
                <div class="matrix-subtitle">Importance Weights [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="sigmaMatrix" width="200" height="200"></canvas>
                </div>
            </div>

            <div class="matrix-section">
                <div class="matrix-title">V<sup>T</sup></div>
                <div class="matrix-subtitle">Principal Color Axes [3 x 3]</div>
                <div class="matrix-canvas-container">
                    <canvas id="vMatrix" width="200" height="200"></canvas>
                </div>
            </div>
        </div>

        <div class="equation">
            A<sub>f</sub> = U × Σ × V<sup>T</sup> &nbsp;&nbsp;
        </div>
        <div class="flattening-note">
            A [100×100×3] → A<sub>f</sub> [10000×3]
        </div>

        <div class="controls">
            <div class="slider-container">
                <div class="slider-group" id="colorSliderGroup">
                    <label for="colorSlider">Colors: <span class="slider-value" id="colorValue">3</span></label>
                    <input type="range" id="colorSlider" class="slider" min="1" max="10" value="3">
                </div>
                <div class="slider-group" id="shapeSliderGroup">
                    <label for="shapeSlider">Shapes: <span class="slider-value" id="shapeValue">3</span></label>
                    <input type="range" id="shapeSlider" class="slider" min="1" max="10" value="3">
                </div>
                <div class="slider-group" id="rankSliderGroup">
                    <label for="rankSlider">Rank: <span class="slider-value" id="rankValue">3</span></label>
                    <input type="range" id="rankSlider" class="slider" min="0" max="3" value="3">
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { CONFIG } from './scripts/svd-color-space/constants.js';
        import { AppState } from './scripts/svd-color-space/app-state.js';

        // Image dimensions
        const imageSize = CONFIG.IMAGE_SIZE;
        const canvasSize = CONFIG.CANVAS_SIZE;

        // Initialize application state
        const appState = new AppState();

        // Initialize the visualization
        function init() {
            // Generate initial fixed shapes
            appState.fixedShapes = generateShapes(appState.shapeComplexity, []); // Empty colors initially
            generateComplexImage(appState.colorComplexity, appState.shapeComplexity);
            performSVD();

            // Set initial rank to match the actual rank and update slider limits
            updateRankSliderLimits();
            appState.currentRank = Math.min(appState.colorComplexity, 3);
            document.getElementById('rankSlider').value = appState.currentRank;
            document.getElementById('rankValue').textContent = appState.currentRank;

            // Set up rank slider interaction listeners
            setupRankSliderInteraction();

            // Set up event listeners for sliders
            document.getElementById('colorSlider').addEventListener('input', updateSliders);
            document.getElementById('shapeSlider').addEventListener('input', updateSliders);
            document.getElementById('rankSlider').addEventListener('input', updateRankSlider);

            drawAll();
        }

        // Update rank slider limits based on current color complexity
        function updateRankSliderLimits() {
            const actualRank = Math.min(appState.colorComplexity, 3);
            const rankSlider = document.getElementById('rankSlider');

            // Update max value to match actual rank
            rankSlider.max = actualRank;

            // If current rank is higher than the new max, adjust it
            if (appState.currentRank > actualRank) {
                appState.currentRank = actualRank;
                rankSlider.value = appState.currentRank;
                document.getElementById('rankValue').textContent = appState.currentRank;
            }
        }

        // Set up rank slider interaction detection
        function setupRankSliderInteraction() {
            const rankSlider = document.getElementById('rankSlider');

            // Mouse events
            rankSlider.addEventListener('mousedown', () => {
                appState.isRankSliderActive = true;
                // Immediately show highlighting when user starts dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('mouseup', () => {
                appState.isRankSliderActive = false;
                // Hide highlighting when user stops dragging
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            // Touch events for mobile
            rankSlider.addEventListener('touchstart', () => {
                appState.isRankSliderActive = true;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });

            rankSlider.addEventListener('touchend', () => {
                appState.isRankSliderActive = false;
                drawUMatrix();
                drawSigmaMatrix();
                drawVMatrix();
                updateULabels();
            });
        }

        // Update slider values and regenerate image
        function updateSliders() {
            const newColorComplexity = parseInt(document.getElementById('colorSlider').value);
            const newShapeComplexity = parseInt(document.getElementById('shapeSlider').value);

            // Auto-adjust logic: ensure we have enough shapes to support the color complexity
            let adjustedColorComplexity = newColorComplexity;
            let adjustedShapeComplexity = newShapeComplexity;

            // If user increases color complexity beyond shape complexity, increase shapes too
            if (newColorComplexity > appState.shapeComplexity && newColorComplexity !== appState.colorComplexity) {
                adjustedShapeComplexity = Math.max(newShapeComplexity, newColorComplexity);
                document.getElementById('shapeSlider').value = adjustedShapeComplexity;
                document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('shapeSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('shapeSliderGroup').classList.remove('slider-auto-adjusted');
                }, CONFIG.ANIMATION_DURATION);

                // Show brief notification
                showSliderNotification(`Shape complexity automatically increased to ${adjustedShapeComplexity} to support ${newColorComplexity} colors`);
            }

            // If user decreases shape complexity below color complexity, decrease colors too
            if (newShapeComplexity < appState.colorComplexity && newShapeComplexity !== appState.shapeComplexity) {
                adjustedColorComplexity = Math.min(newColorComplexity, newShapeComplexity);
                document.getElementById('colorSlider').value = adjustedColorComplexity;
                document.getElementById('colorValue').textContent = adjustedColorComplexity;

                // Visual feedback for auto-adjustment
                document.getElementById('colorSliderGroup').classList.add('slider-auto-adjusted');
                setTimeout(() => {
                    document.getElementById('colorSliderGroup').classList.remove('slider-auto-adjusted');
                }, CONFIG.ANIMATION_DURATION);

                // Show brief notification
                showSliderNotification(`Color complexity automatically decreased to ${adjustedColorComplexity} to match ${newShapeComplexity} shapes`);
            }

            // Update display values
            document.getElementById('colorValue').textContent = adjustedColorComplexity;
            document.getElementById('shapeValue').textContent = adjustedShapeComplexity;

            // Add or remove shapes if shape complexity changed
            if (adjustedShapeComplexity !== appState.shapeComplexity) {
                if (adjustedShapeComplexity > appState.shapeComplexity) {
                    addShapesToPattern(adjustedShapeComplexity - appState.shapeComplexity);
                }
            }

            appState.colorComplexity = adjustedColorComplexity;
            appState.shapeComplexity = adjustedShapeComplexity;

            generateComplexImage(appState.colorComplexity, appState.shapeComplexity);
            performSVD();

            // Update rank slider limits and preserve current rank if still valid
            updateRankSliderLimits();

            drawAll();
        }

        // Update rank slider and display approximation
        function updateRankSlider() {
            const newRank = parseInt(document.getElementById('rankSlider').value);
            appState.currentRank = newRank;

            // Update display value
            document.getElementById('rankValue').textContent = appState.currentRank;

            // Update the title based on rank
            updateImageTitle();

            // Redraw with current highlighting state (depends on isRankSliderActive)
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateULabels();
        }        // Briefly highlight all components at full rank, then fade to default

        function updateImageTitle() {
            const subtitleElement = document.querySelector('.matrix-subtitle');
            const actualRank = Math.min(appState.colorComplexity, 3); // Actual rank of the image

            if (appState.currentRank === actualRank) {
                subtitleElement.innerHTML = 'Original [100×100×3]';
            } else if (appState.currentRank === 0) {
                subtitleElement.innerHTML = 'Zero [100×100×3]';
            } else {
                subtitleElement.innerHTML = `Rank-${appState.currentRank} Approximation [100×100×3]`;
            }
        }

        // Add notification function
        function showSliderNotification(message) {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('sliderNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'sliderNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #007bff;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 10000;
                    font-size: 14px;
                    max-width: 400px;
                    text-align: center;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(notification);
            }

            // Show notification
            notification.textContent = message;
            notification.style.opacity = '1';

            // Hide after 2.5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2500);
        }

        function generateComplexImage(colorComplexity, shapeComplexity) {
            // Initialize image with background
            appState.imageData = new Array(imageSize);
            for (let i = 0; i < imageSize; i++) {
                appState.imageData[i] = new Array(imageSize);
                for (let j = 0; j < imageSize; j++) {
                    appState.imageData[i][j] = [0, 0, 0]; // Black background
                }
            }

            // Generate color palette based on complexity
            const colors = getColorPalette(colorComplexity);

            // Use fixed shapes but apply current colors
            const shapesToDraw = assignColorsToFixedShapes(appState.fixedShapes, colors, shapeComplexity);

            // Draw shapes to the image
            drawShapes(shapesToDraw);
        }

        function assignColorsToFixedShapes(shapes, colors, shapeComplexity) {
            // Take only the number of shapes we want based on current complexity
            const activeShapes = shapes.slice(0, Math.min(shapeComplexity, shapes.length));

            // Always reassign colors cyclically to ensure color changes are reflected
            // This ensures that when color complexity changes, all shapes get new color assignments
            const shapesWithColors = activeShapes.map((shape, index) => {
                const assignedColor = colors.length > 0 ? colors[index % colors.length] : [255, 255, 255];
                return {
                    ...shape,
                    color: assignedColor
                };
            });

            return shapesWithColors;
        }

        function getColorPalette(complexity) {
            const baseColors = CONFIG.COLORS;

            return baseColors.slice(0, Math.min(complexity, baseColors.length));
        }

        function generateShapes(complexity, colors) {
            const shapes = [];
            const shapeTypes = CONFIG.SHAPE_TYPES;

            // Generate up to 10 shapes with fixed positions but no colors yet
            for (let i = 0; i < CONFIG.MAX_SHAPES; i++) { // Always generate 10 potential shapes
                const shapeType = shapeTypes[i % shapeTypes.length];

                shapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }

            return shapes;
        }

        function addShapesToPattern(numNewShapes) {
            const shapeTypes = CONFIG.SHAPE_TYPES;

            // Add new shapes to the existing pattern
            for (let i = 0; i < numNewShapes && appState.fixedShapes.length < CONFIG.MAX_SHAPES; i++) {
                const currentShapeIndex = appState.fixedShapes.length;
                const shapeType = shapeTypes[currentShapeIndex % shapeTypes.length];

                appState.fixedShapes.push({
                    type: shapeType,
                    color: null, // Color will be assigned later
                    x: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    y: Math.floor(Math.random() * (imageSize - 40)) + 20,
                    size: Math.floor(Math.random() * 20) + 15,
                    rotation: Math.random() * 2 * Math.PI
                });
            }
        }

        function drawShapes(shapes) {
            shapes.forEach(shape => {
                switch (shape.type) {
                    case 'circle':
                        drawCircle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'rectangle':
                        drawRectangle(shape.x, shape.y, shape.size, shape.size, shape.color);
                        break;
                    case 'triangle':
                        drawTriangle(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'diamond':
                        drawDiamond(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'pentagon':
                        drawPolygon(shape.x, shape.y, shape.size, 5, shape.color, shape.rotation);
                        break;
                    case 'hexagon':
                        drawPolygon(shape.x, shape.y, shape.size, 6, shape.color, shape.rotation);
                        break;
                    case 'star':
                        drawStar(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'ellipse':
                        drawEllipse(shape.x, shape.y, shape.size, shape.size * 0.7, shape.color);
                        break;
                    case 'cross':
                        drawCross(shape.x, shape.y, shape.size, shape.color);
                        break;
                    case 'heart':
                        drawHeart(shape.x, shape.y, shape.size, shape.color);
                        break;
                }
            });
        }

        function drawCircle(cx, cy, radius, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dist = Math.sqrt((i - cy) ** 2 + (j - cx) ** 2);
                    if (dist <= radius) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawRectangle(x, y, width, height, color) {
            for (let i = Math.max(0, Math.floor(y)); i < Math.min(imageSize, Math.ceil(y + height)); i++) {
                for (let j = Math.max(0, Math.floor(x)); j < Math.min(imageSize, Math.ceil(x + width)); j++) {
                    if (i >= 0 && i < imageSize && j >= 0 && j < imageSize) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawTriangle(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Simple right triangle
                    const relativeI = i - cy;
                    const relativeJ = j - cx;
                    if (relativeJ >= 0 && relativeI >= 0 && relativeJ < (size - relativeI) && relativeI < size) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawDiamond(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = Math.abs(j - cx);
                    const dy = Math.abs(i - cy);
                    if (dx + dy <= size) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawPolygon(cx, cy, size, sides, color, rotation) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx) + rotation;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Approximate polygon as circle for simplicity
                    const polygonRadius = size * Math.cos(Math.PI / sides) / Math.cos((angle % (2 * Math.PI / sides)) - Math.PI / sides);
                    if (dist <= Math.abs(polygonRadius) && dist <= size) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawStar(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = j - cx;
                    const dy = i - cy;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Simple 5-pointed star approximation
                    const starAngle = ((angle + Math.PI) % (2 * Math.PI / 5)) - Math.PI / 5;
                    const starRadius = size * (0.5 + 0.5 * Math.cos(5 * starAngle));
                    if (dist <= starRadius) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawEllipse(cx, cy, width, height, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / width;
                    const dy = (i - cy) / height;
                    if (dx * dx + dy * dy <= 1) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function drawCross(cx, cy, size, color) {
            const thickness = Math.max(3, Math.floor(size / 4));
            // Horizontal bar
            const hx = Math.floor(cx - size);
            const hy = Math.floor(cy - thickness / 2);
            const hwidth = Math.floor(size * 2);
            const hheight = Math.floor(thickness);
            drawRectangle(hx, hy, hwidth, hheight, color);

            // Vertical bar  
            const vx = Math.floor(cx - thickness / 2);
            const vy = Math.floor(cy - size);
            const vwidth = Math.floor(thickness);
            const vheight = Math.floor(size * 2);
            drawRectangle(vx, vy, vwidth, vheight, color);
        }

        function drawHeart(cx, cy, size, color) {
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const dx = (j - cx) / size;
                    const dy = (i - cy) / size;

                    // Heart equation approximation
                    const heartEq = Math.pow(dx * dx + dy * dy - 1, 3) - dx * dx * dy * dy * dy;
                    if (heartEq <= 0 && dx * dx + dy * dy <= 2) {
                        appState.imageData[i][j] = color;
                    }
                }
            }
        }

        function performSVD() {
            // Convert the 3D image array (100x100x3) into a 2D matrix (10000x3)
            // Each row represents a pixel with its RGB values
            const imageMatrix = [];
            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    // Normalize to 0-1 range for better numerical stability
                    const [r, g, b] = appState.imageData[i][j];
                    imageMatrix.push([r / 255, g / 255, b / 255]);
                }
            }

            // Perform actual SVD from scratch
            appState.svdResult = computeSVDFromScratch(imageMatrix);

            console.log(appState.svdResult);
        }



        function computeSVDFromScratch(matrix) {
            let A = new mlMatrix.Matrix(matrix);

            // Perform SVD
            const svd = new mlMatrix.SingularValueDecomposition(A);

            // Extract components
            const U = svd.leftSingularVectors.to2DArray();
            const sigma = svd.diagonal;
            const V = svd.rightSingularVectors.to2DArray();

            // Transpose V to get V^T (ML-Matrix returns V, but we need V^T)
            const VT = [];
            for (let i = 0; i < V[0].length; i++) {
                VT[i] = [];
                for (let j = 0; j < V.length; j++) {
                    VT[i][j] = V[j][i];
                }
            }

            // Fix sign ambiguity: make the largest absolute value in each V^T row positive
            for (let i = 0; i < VT.length; i++) {
                const row = VT[i];
                let maxAbsIdx = 0;
                let maxAbsVal = Math.abs(row[0]);

                for (let j = 1; j < row.length; j++) {
                    if (Math.abs(row[j]) > maxAbsVal) {
                        maxAbsVal = Math.abs(row[j]);
                        maxAbsIdx = j;
                    }
                }

                // If the largest element is negative, flip the sign of the entire row
                // and corresponding column in U
                if (row[maxAbsIdx] < 0) {
                    for (let j = 0; j < row.length; j++) {
                        VT[i][j] = -VT[i][j];
                    }
                    for (let k = 0; k < U.length; k++) {
                        U[k][i] = -U[k][i];
                    }
                }
            }

            return { U, sigma, VT };
        }

        function drawAll() {
            drawOriginalImageWithRank();
            drawUMatrix();
            drawSigmaMatrix();
            drawVMatrix();
            updateImageTitle();
        }

        function drawOriginalImageWithRank() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvasSize, canvasSize);

            // Check if we're hovering over A and should use top-k RGB components
            const useTopKRGBComponents = appState.hoveredOriginalImage;

            if (appState.currentRank === 0) {
                // Black image for rank 0
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = 0;     // Red
                    imageData.data[i + 1] = 0; // Green
                    imageData.data[i + 2] = 0; // Blue
                    imageData.data[i + 3] = 255; // Alpha
                }
            } else {
                // Check if we're hovering over A and should use top-k RGB components
                const useTopKRGBComponents = appState.hoveredOriginalImage;
                let componentsToUse;

                if (useTopKRGBComponents) {
                    // In RGB mode, use top k RGB channels based on their standard deviations
                    const rgbChannels = getRGBChannelsByStdDev();
                    const topKChannels = rgbChannels.slice(0, appState.currentRank);

                    // Reconstruct using only selected RGB channels (not SVD components)
                    for (let i = 0; i < canvasSize; i++) {
                        for (let j = 0; j < canvasSize; j++) {
                            // Map canvas coordinates to image coordinates
                            const imgI = Math.floor(i * imageSize / canvasSize);
                            const imgJ = Math.floor(j * imageSize / canvasSize);

                            // Get original RGB values
                            const [originalR, originalG, originalB] = appState.imageData[imgI][imgJ];

                            // Start with black and add only the selected RGB channels
                            let r = 0, g = 0, b = 0;

                            // Add contributions from the top k RGB channels only
                            topKChannels.forEach(channel => {
                                if (channel.channel === 'R') r = originalR;
                                if (channel.channel === 'G') g = originalG;
                                if (channel.channel === 'B') b = originalB;
                            });

                            const pixelIndex = (i * canvasSize + j) * 4;
                            imageData.data[pixelIndex] = r;     // Red
                            imageData.data[pixelIndex + 1] = g; // Green
                            imageData.data[pixelIndex + 2] = b; // Blue
                            imageData.data[pixelIndex + 3] = 255; // Alpha
                        }
                    }

                    // Skip the SVD reconstruction since we did RGB reconstruction above
                    ctx.putImageData(imageData, 0, 0);
                    setupOriginalImageInteraction();
                    return;
                } else {
                    // Use the first k components in order (normal SVD behavior)
                    componentsToUse = [];
                    for (let k = 0; k < appState.currentRank; k++) {
                        componentsToUse.push({ index: k });
                    }
                }

                // Compute rank-k approximation
                for (let i = 0; i < canvasSize; i++) {
                    for (let j = 0; j < canvasSize; j++) {
                        // Map canvas coordinates to image coordinates
                        const imgI = Math.floor(i * imageSize / canvasSize);
                        const imgJ = Math.floor(j * imageSize / canvasSize);
                        const flatIndex = imgI * imageSize + imgJ;

                        // Compute rank-k approximation: sum of selected components
                        let r = 0, g = 0, b = 0;
                        componentsToUse.forEach(comp => {
                            const k = comp.index;
                            const sigma = appState.svdResult.sigma[k];
                            const u_val = appState.svdResult.U[flatIndex][k];
                            const v_r = appState.svdResult.VT[k][0];
                            const v_g = appState.svdResult.VT[k][1];
                            const v_b = appState.svdResult.VT[k][2];

                            r += u_val * sigma * v_r;
                            g += u_val * sigma * v_g;
                            b += u_val * sigma * v_b;
                        });

                        // Scale and clamp to [0, 255]
                        r = Math.max(0, Math.min(255, r * 255));
                        g = Math.max(0, Math.min(255, g * 255));
                        b = Math.max(0, Math.min(255, b * 255));

                        const pixelIndex = (i * canvasSize + j) * 4;
                        imageData.data[pixelIndex] = r;     // Red
                        imageData.data[pixelIndex + 1] = g; // Green
                        imageData.data[pixelIndex + 2] = b; // Blue
                        imageData.data[pixelIndex + 3] = 255; // Alpha
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Setup hover interaction for original image A
            setupOriginalImageInteraction();
        }

        function setupOriginalImageInteraction() {
            const canvas = document.getElementById('originalImage');

            // Remove existing listeners to prevent duplicates
            canvas.onmouseenter = null;
            canvas.onmouseleave = null;

            canvas.onmouseenter = function () {
                if (!appState.hoveredOriginalImage) {
                    appState.hoveredOriginalImage = true;
                    drawRGBChannelsInMainMatrices();
                    // Also update matrix A to show rank-k approximation using top RGB channels
                    drawOriginalImageWithRank();
                }
            };

            canvas.onmousemove = function (event) {
                if (appState.hoveredOriginalImage) {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;

                    // Convert canvas coordinates to image coordinates
                    const imgX = Math.floor(x * imageSize / canvasSize);
                    const imgY = Math.floor(y * imageSize / canvasSize);

                    // Get the RGB values from the displayed rank-k approximation at this position
                    if (imgX >= 0 && imgX < imageSize && imgY >= 0 && imgY < imageSize) {
                        const [r, g, b] = getRankApproximationRGBAt(imgX, imgY);
                        drawRGBChannelsWithHighlight(imgX, imgY, r, g, b);
                        // Keep the rank-k approximation in A updated
                        drawOriginalImageWithRank();
                    }
                }
            };

            canvas.onmouseleave = function () {
                if (appState.hoveredOriginalImage) {
                    // First restore the original image display in A (while still hovering)
                    appState.hoveredOriginalImage = false;
                    drawOriginalImageWithRank();

                    // Then restore all the other UI elements
                    // Restore U matrix display
                    const uMatrixContainer = document.querySelector('.matrix-section:nth-child(2) .matrix-canvas-container');
                    const originalUDisplay = uMatrixContainer.querySelector('div[style*="display: flex"], div[style*="display: none"]');
                    if (originalUDisplay) {
                        originalUDisplay.style.display = 'flex';
                    }

                    // Hide the red overlay canvas
                    const redOverlayCanvas = document.getElementById('redOverlayCanvas');
                    if (redOverlayCanvas) {
                        redOverlayCanvas.style.display = 'none';
                    }

                    // Restore original titles and subtitles
                    const mainTitle = document.querySelector('h1');
                    mainTitle.textContent = 'SVD in Color Space';

                    // Restore original SVD equation
                    const equation = document.querySelector('.equation');
                    if (equation) {
                        equation.innerHTML = 'A<sub>f</sub> = U × Σ × V<sup>T</sup> &nbsp;&nbsp;';
                    }

                    const uTitle = document.querySelector('.matrix-section:nth-child(2) .matrix-title');
                    const uSubtitle = document.querySelector('.matrix-section:nth-child(2) .matrix-subtitle');
                    const sigmaTitle = document.querySelector('.matrix-section:nth-child(3) .matrix-title');
                    const sigmaSubtitle = document.querySelector('.matrix-section:nth-child(3) .matrix-subtitle');
                    const vTitle = document.querySelector('.matrix-section:nth-child(4) .matrix-title');
                    const vSubtitle = document.querySelector('.matrix-section:nth-child(4) .matrix-subtitle');

                    uTitle.innerHTML = 'U';
                    uTitle.style.color = '';
                    uSubtitle.innerHTML = 'Spatial Activations [10,000 × 3]';

                    sigmaTitle.innerHTML = 'Σ';
                    sigmaTitle.style.color = '';
                    sigmaSubtitle.innerHTML = 'Importance Weights [3 x 3]';

                    vTitle.innerHTML = 'V<sup>T</sup>';
                    vTitle.style.color = '';
                    vSubtitle.innerHTML = 'Principal Color Axes [3 x 3]';

                    // Remove RGB mode class for mobile
                    document.body.classList.remove('rgb-mode');

                    // Clear RGB highlighting state
                    window.rgbHighlightRows = null;

                    // Restore original matrices
                    drawUMatrix();
                    drawSigmaMatrix();
                    drawVMatrix();
                    updateULabels();
                }
            };
        }

        function drawRGBChannelsInMainMatrices() {
            // Update main page title
            const mainTitle = document.querySelector('h1');
            mainTitle.textContent = 'RGB Channel Decomposition';

            // Change equation to show RGB identity decomposition
            const equation = document.querySelector('.equation');
            if (equation) {
                equation.innerHTML = 'A<sub>f</sub> = A<sub>f</sub> × I &nbsp;&nbsp;';
            }

            // Show the individual U column matrices and draw RGB channels in them
            const uMatrixContainer = document.querySelector('.matrix-section:nth-child(2) .matrix-canvas-container');

            // Make sure the original U matrix display is visible
            const originalUDisplay = uMatrixContainer.querySelector('div[style*="display: flex"], div[style*="display: none"]');
            if (originalUDisplay) {
                originalUDisplay.style.display = 'flex';
            }

            // Hide any existing red overlay canvas
            const redOverlayCanvas = document.getElementById('redOverlayCanvas');
            if (redOverlayCanvas) {
                redOverlayCanvas.style.display = 'none';
            }

            const uCanvasSize = CONFIG.U_CANVAS_SIZE;

            // Draw Red channel in first U column (uMatrix0)
            const redCanvas = document.getElementById('uMatrix0');
            const redCtx = redCanvas.getContext('2d');
            const redImageData = redCtx.createImageData(uCanvasSize, uCanvasSize);

            // Draw Green channel in second U column (uMatrix1)
            const greenCanvas = document.getElementById('uMatrix1');
            const greenCtx = greenCanvas.getContext('2d');
            const greenImageData = greenCtx.createImageData(uCanvasSize, uCanvasSize);

            // Draw Blue channel in third U column (uMatrix2)
            const blueCanvas = document.getElementById('uMatrix2');
            const blueCtx = blueCanvas.getContext('2d');
            const blueImageData = blueCtx.createImageData(uCanvasSize, uCanvasSize);

            for (let i = 0; i < uCanvasSize; i++) {
                for (let j = 0; j < uCanvasSize; j++) {
                    const imgI = Math.floor(i * imageSize / uCanvasSize);
                    const imgJ = Math.floor(j * imageSize / uCanvasSize);
                    const pixelIndex = (i * uCanvasSize + j) * 4;
                    const [r, g, b] = appState.imageData[imgI][imgJ];

                    // Red channel (color-tinted)
                    redImageData.data[pixelIndex] = r;         // Red component
                    redImageData.data[pixelIndex + 1] = 0;     // No green
                    redImageData.data[pixelIndex + 2] = 0;     // No blue
                    redImageData.data[pixelIndex + 3] = 255;   // Alpha

                    // Green channel (color-tinted)
                    greenImageData.data[pixelIndex] = 0;       // No red
                    greenImageData.data[pixelIndex + 1] = g;   // Green component
                    greenImageData.data[pixelIndex + 2] = 0;   // No blue
                    greenImageData.data[pixelIndex + 3] = 255; // Alpha

                    // Blue channel (color-tinted)
                    blueImageData.data[pixelIndex] = 0;        // No red
                    blueImageData.data[pixelIndex + 1] = 0;    // No green
                    blueImageData.data[pixelIndex + 2] = b;    // Blue component
                    blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                }
            }

            redCtx.putImageData(redImageData, 0, 0);
            greenCtx.putImageData(greenImageData, 0, 0);
            blueCtx.putImageData(blueImageData, 0, 0);

            // Update U matrix labels to show RGB channels
            document.getElementById('uLabel0').innerHTML = 'A<sub>R</sub>';
            document.getElementById('uShapeInfo0').innerHTML = '→ [100 × 100]';
            document.getElementById('uLabel1').innerHTML = 'A<sub>G</sub>';
            document.getElementById('uShapeInfo1').innerHTML = '→ [100 × 100]';
            document.getElementById('uLabel2').innerHTML = 'A<sub>B</sub>';
            document.getElementById('uShapeInfo2').innerHTML = '→ [100 × 100]';

            // Update U matrix title and subtitle
            const uTitle = document.querySelector('.matrix-section:nth-child(2) .matrix-title');
            const uSubtitle = document.querySelector('.matrix-section:nth-child(2) .matrix-subtitle');
            uTitle.innerHTML = 'A<sub>f</sub>';
            uTitle.style.color = '#333';
            uSubtitle.innerHTML = 'Channel Activations [10,000 x 3]';

            // Calculate variance squared for each color channel
            const sigmaCanvas = document.getElementById('sigmaMatrix');
            const sigmaCtx = sigmaCanvas.getContext('2d');

            // Clear canvas with white background (same as original)
            sigmaCtx.fillStyle = 'white';
            sigmaCtx.fillRect(0, 0, canvasSize, canvasSize);

            // Calculate variance for each channel across all pixels
            let redSum = 0, greenSum = 0, blueSum = 0;
            let redSumSq = 0, greenSumSq = 0, blueSumSq = 0;
            const totalPixels = imageSize * imageSize;

            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const [r, g, b] = appState.imageData[i][j];

                    redSum += r;
                    greenSum += g;
                    blueSum += b;

                    redSumSq += r * r;
                    greenSumSq += g * g;
                    blueSumSq += b * b;
                }
            }

            // Calculate variance = E[X²] - (E[X])²
            const redMean = redSum / totalPixels;
            const greenMean = greenSum / totalPixels;
            const blueMean = blueSum / totalPixels;

            const redVariance = (redSumSq / totalPixels) - (redMean * redMean);
            const greenVariance = (greenSumSq / totalPixels) - (greenMean * greenMean);
            const blueVariance = (blueSumSq / totalPixels) - (blueMean * blueMean);

            // Take square root to get standard deviation (analogous to singular values)
            const redStdDev = Math.sqrt(redVariance);
            const greenStdDev = Math.sqrt(greenVariance);
            const blueStdDev = Math.sqrt(blueVariance);

            // Use same drawing style as original sigma matrix
            const stdDevs = [redStdDev, greenStdDev, blueStdDev];
            const colors = ['#e74c3c', '#27ae60', '#3498db'];
            const labels = ['R', 'G', 'B'];

            const maxStdDev = Math.max(...stdDevs);
            const barWidth = canvasSize / stdDevs.length;
            const margin = 20;

            for (let i = 0; i < stdDevs.length; i++) {
                const height = ((stdDevs[i] / maxStdDev) * (canvasSize - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = canvasSize - margin - height;
                const w = barWidth * 0.8;

                // Use channel colors instead of blue/gray
                sigmaCtx.fillStyle = colors[i];
                sigmaCtx.fillRect(x, y, w, height);

                // Add value label (same style as original)
                sigmaCtx.fillStyle = 'black';
                sigmaCtx.font = '12px Arial';
                sigmaCtx.textAlign = 'center';
                sigmaCtx.fillText(stdDevs[i].toFixed(1), i * barWidth + barWidth / 2, canvasSize - 5);
                sigmaCtx.fillText(`σ${labels[i]}`, i * barWidth + barWidth / 2, y - 5);
            }

            // Temporarily replace appState.svdResult.VT with RGB identity matrix and reuse drawVMatrix()
            const originalVT = appState.svdResult.VT;

            // Set RGB identity matrix: [1,0,0], [0,1,0], [0,0,1]
            appState.svdResult.VT = [
                [1, 0, 0], // Red row
                [0, 1, 0], // Green row  
                [0, 0, 1]  // Blue row
            ];

            // Call the existing drawVMatrix function to maintain consistent styling
            drawVMatrix();

            // Restore original VT matrix
            appState.svdResult.VT = originalVT;

            // Update Sigma matrix title and subtitle
            const sigmaTitle = document.querySelector('.matrix-section:nth-child(3) .matrix-title');
            const sigmaSubtitle = document.querySelector('.matrix-section:nth-child(3) .matrix-subtitle');
            sigmaTitle.innerHTML = 'Σ<sub>RGB</sub>';
            sigmaTitle.style.color = '#333';
            sigmaSubtitle.innerHTML = 'Standard Deviation [R, G, B]';

            // Update V^T matrix title and subtitle
            const vTitle = document.querySelector('.matrix-section:nth-child(4) .matrix-title');
            const vSubtitle = document.querySelector('.matrix-section:nth-child(4) .matrix-subtitle');
            vTitle.innerHTML = 'I';
            vTitle.style.color = '#333';
            vSubtitle.innerHTML = 'RGB Color Axes [3 x 3]';

            // Add special class for mobile RGB display
            document.body.classList.add('rgb-mode');
        }

        function drawRGBChannelsWithHighlight(hoverX, hoverY, hoverR, hoverG, hoverB) {
            // Determine which channels have significant contribution (non-zero or above threshold)
            const threshold = CONFIG.HOVER_THRESHOLD; // Minimum value to consider "contributing"
            const redActive = hoverR > threshold;
            const greenActive = hoverG > threshold;
            const blueActive = hoverB > threshold;

            const uCanvasSize = CONFIG.U_CANVAS_SIZE;

            // Draw Red channel in first U column (uMatrix0) with conditional highlighting
            const redCanvas = document.getElementById('uMatrix0');
            const redCtx = redCanvas.getContext('2d');
            const redImageData = redCtx.createImageData(uCanvasSize, uCanvasSize);

            // Draw Green channel in second U column (uMatrix1) with conditional highlighting
            const greenCanvas = document.getElementById('uMatrix1');
            const greenCtx = greenCanvas.getContext('2d');
            const greenImageData = greenCtx.createImageData(uCanvasSize, uCanvasSize);

            // Draw Blue channel in third U column (uMatrix2) with conditional highlighting
            const blueCanvas = document.getElementById('uMatrix2');
            const blueCtx = blueCanvas.getContext('2d');
            const blueImageData = blueCtx.createImageData(uCanvasSize, uCanvasSize);

            for (let i = 0; i < uCanvasSize; i++) {
                for (let j = 0; j < uCanvasSize; j++) {
                    const imgI = Math.floor(i * imageSize / uCanvasSize);
                    const imgJ = Math.floor(j * imageSize / uCanvasSize);
                    const pixelIndex = (i * uCanvasSize + j) * 4;
                    const [r, g, b] = appState.imageData[imgI][imgJ];

                    // Red channel with conditional highlighting
                    if (redActive) {
                        // Full red channel display
                        redImageData.data[pixelIndex] = r;         // Red component
                        redImageData.data[pixelIndex + 1] = 0;     // No green
                        redImageData.data[pixelIndex + 2] = 0;     // No blue
                        redImageData.data[pixelIndex + 3] = 255;   // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        redImageData.data[pixelIndex] = r;         // Red = intensity
                        redImageData.data[pixelIndex + 1] = r;     // Green = intensity
                        redImageData.data[pixelIndex + 2] = r;     // Blue = intensity
                        redImageData.data[pixelIndex + 3] = 255;   // Alpha
                    }

                    // Green channel with conditional highlighting
                    if (greenActive) {
                        // Full green channel display
                        greenImageData.data[pixelIndex] = 0;       // No red
                        greenImageData.data[pixelIndex + 1] = g;   // Green component
                        greenImageData.data[pixelIndex + 2] = 0;   // No blue
                        greenImageData.data[pixelIndex + 3] = 255; // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        greenImageData.data[pixelIndex] = g;       // Red = intensity
                        greenImageData.data[pixelIndex + 1] = g;   // Green = intensity
                        greenImageData.data[pixelIndex + 2] = g;   // Blue = intensity
                        greenImageData.data[pixelIndex + 3] = 255; // Alpha
                    }

                    // Blue channel with conditional highlighting
                    if (blueActive) {
                        // Full blue channel display
                        blueImageData.data[pixelIndex] = 0;        // No red
                        blueImageData.data[pixelIndex + 1] = 0;    // No green
                        blueImageData.data[pixelIndex + 2] = b;    // Blue component
                        blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                    } else {
                        // Grayscale representation showing intensity (white = high intensity)
                        blueImageData.data[pixelIndex] = b;        // Red = intensity
                        blueImageData.data[pixelIndex + 1] = b;    // Green = intensity
                        blueImageData.data[pixelIndex + 2] = b;    // Blue = intensity
                        blueImageData.data[pixelIndex + 3] = 255;  // Alpha
                    }
                }
            }

            redCtx.putImageData(redImageData, 0, 0);
            greenCtx.putImageData(greenImageData, 0, 0);
            blueCtx.putImageData(blueImageData, 0, 0);

            // Add highlight cursors at hover position for active channels
            const cursorX = hoverX * uCanvasSize / imageSize;
            const cursorY = hoverY * uCanvasSize / imageSize;

            if (redActive) {
                redCtx.strokeStyle = '#fff';
                redCtx.lineWidth = 2;
                redCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            if (greenActive) {
                greenCtx.strokeStyle = '#fff';
                greenCtx.lineWidth = 2;
                greenCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            if (blueActive) {
                blueCtx.strokeStyle = '#fff';
                blueCtx.lineWidth = 2;
                blueCtx.strokeRect(cursorX - 2, cursorY - 2, 4, 4);
            }

            // Update labels to show current pixel values and activity status
            const redLabel = document.getElementById('uLabel0');
            const greenLabel = document.getElementById('uLabel1');
            const blueLabel = document.getElementById('uLabel2');

            // Also update shape info
            const redShapeInfo = document.getElementById('uShapeInfo0');
            const greenShapeInfo = document.getElementById('uShapeInfo1');
            const blueShapeInfo = document.getElementById('uShapeInfo2');

            // Calculate dynamic colors based on RGB identity matrix (same as sigma bars)
            const rgbIdentityRows = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
            const labels = [redLabel, greenLabel, blueLabel];
            const shapeInfos = [redShapeInfo, greenShapeInfo, blueShapeInfo];
            const activeStates = [redActive, greenActive, blueActive];
            const values = [hoverR, hoverG, hoverB];
            const subscripts = ['R', 'G', 'B'];

            for (let i = 0; i < 3; i++) {

                let labelColor = '#333';
                let shapeInfoColor = '#666';
                if (activeStates[i]) {
                    const row = rgbIdentityRows[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    let r = Math.floor((rVal / maxVal) * 255);
                    let g = Math.floor((gVal / maxVal) * 255);
                    let b = Math.floor((bVal / maxVal) * 255);

                    // Calculate luminance using standard formula
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                    // If the color is too light (luminance > 127), darken it for better contrast
                    if (luminance > 127) {
                        // Darken more aggressively by reducing all components proportionally
                        const darkenFactor = 0.7;
                        r = Math.floor(r * darkenFactor);
                        g = Math.floor(g * darkenFactor);
                        b = Math.floor(b * darkenFactor);
                    }

                    labelColor = `rgb(${r}, ${g}, ${b})`;

                    labels[i].innerHTML = `a<sub>f${i + 1}</sub>e<sub>${i + 1}</sub><sup>T</sup>`;
                    shapeInfos[i].innerHTML = `[100 × 100 x 3]`;
                    shapeInfos[i].style.color = labelColor;
                }
                else {
                    labels[i].innerHTML = `A<sub>f [:,${i + 1}]</sub>`;
                    shapeInfos[i].innerHTML = '→ [100 × 100]';
                    shapeInfos[i].style.color = shapeInfoColor;
                }
                labels[i].style.color = labelColor;
            }

            // Update sigma bars with highlighting based on active channels
            drawRGBSigmaWithHighlight(redActive, greenActive, blueActive, hoverR, hoverG, hoverB);

            // Update V^T matrix with highlighting based on active channels
            // Save the original hoveredVTRow state
            const originalHoveredVTRow = appState.hoveredVTRow;

            // Set highlighting based on which color channels are active
            // Since hoveredVTRow can only highlight one row at a time, we need a different approach
            // Let's create a custom highlighting system for multiple rows
            window.rgbHighlightRows = {
                red: redActive,
                green: greenActive,
                blue: blueActive
            };

            // For now, set hoveredVTRow to -1 and modify drawVMatrix to check our custom highlighting
            appState.hoveredVTRow = -1;

            // Draw V^T matrix with RGB identity and highlighting
            const originalVT = appState.svdResult.VT;
            appState.svdResult.VT = [
                [1, 0, 0], // Red row
                [0, 1, 0], // Green row  
                [0, 0, 1]  // Blue row
            ];
            drawVMatrix();
            appState.svdResult.VT = originalVT;

            // Restore original hoveredVTRow state
            appState.hoveredVTRow = originalHoveredVTRow;
        }

        function drawRGBSigmaWithHighlight(redActive, greenActive, blueActive, hoverR, hoverG, hoverB) {
            // Get the sigma canvas and recalculate the RGB standard deviations
            const sigmaCanvas = document.getElementById('sigmaMatrix');
            const sigmaCtx = sigmaCanvas.getContext('2d');

            // Clear canvas with white background
            sigmaCtx.fillStyle = 'white';
            sigmaCtx.fillRect(0, 0, canvasSize, canvasSize);

            // Recalculate RGB standard deviations (same as in drawRGBChannelsInMainMatrices)
            let redSum = 0, greenSum = 0, blueSum = 0;
            let redSumSq = 0, greenSumSq = 0, blueSumSq = 0;
            const totalPixels = imageSize * imageSize;

            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const [r, g, b] = appState.imageData[i][j];

                    redSum += r;
                    greenSum += g;
                    blueSum += b;

                    redSumSq += r * r;
                    greenSumSq += g * g;
                    blueSumSq += b * b;
                }
            }

            const redMean = redSum / totalPixels;
            const greenMean = greenSum / totalPixels;
            const blueMean = blueSum / totalPixels;

            const redVariance = (redSumSq / totalPixels) - (redMean * redMean);
            const greenVariance = (greenSumSq / totalPixels) - (greenMean * greenMean);
            const blueVariance = (blueSumSq / totalPixels) - (blueMean * blueMean);

            const redStdDev = Math.sqrt(redVariance);
            const greenStdDev = Math.sqrt(greenVariance);
            const blueStdDev = Math.sqrt(blueVariance);

            const stdDevs = [redStdDev, greenStdDev, blueStdDev];
            const activeStates = [redActive, greenActive, blueActive];
            const labels = ['R', 'G', 'B'];

            const maxStdDev = Math.max(...stdDevs);
            const barWidth = canvasSize / stdDevs.length;
            const margin = 20;

            for (let i = 0; i < stdDevs.length; i++) {
                const height = ((stdDevs[i] / maxStdDev) * (canvasSize - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = canvasSize - margin - height;
                const w = barWidth * 0.8;

                // Calculate dynamic color based on RGB identity matrix (same approach as SVD sigma bars)
                let barColor = '#999'; // Default gray
                if (activeStates[i]) {
                    // For RGB mode, we use the RGB identity matrix rows: [1,0,0], [0,1,0], [0,0,1]
                    const rgbIdentityRows = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
                    const row = rgbIdentityRows[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    const r = Math.floor((rVal / maxVal) * 255);
                    const g = Math.floor((gVal / maxVal) * 255);
                    const b = Math.floor((bVal / maxVal) * 255);

                    barColor = `rgb(${r}, ${g}, ${b})`;
                }

                sigmaCtx.fillStyle = barColor;
                sigmaCtx.fillRect(x, y, w, height);

                // Add value label (same style as original)
                sigmaCtx.fillStyle = 'black';
                sigmaCtx.font = '12px Arial';
                sigmaCtx.textAlign = 'center';
                sigmaCtx.fillText(stdDevs[i].toFixed(1), i * barWidth + barWidth / 2, canvasSize - 5);
                sigmaCtx.fillText(`σ${labels[i]}`, i * barWidth + barWidth / 2, y - 5);
            }
        }

        function getRankApproximationRGBAt(imgX, imgY) {
            // Calculate the RGB values at the specified position based on the current rank-k approximation
            // This should match what's being displayed in matrix A during hover mode

            if (appState.currentRank === 0) {
                return [0, 0, 0]; // Black for rank 0
            }

            // When hovering, we're in RGB channel mode, so use top k RGB channels
            const rgbChannels = getRGBChannelsByStdDev();
            const topKChannels = rgbChannels.slice(0, appState.currentRank);

            // Get original RGB values at this position
            const [originalR, originalG, originalB] = appState.imageData[imgY][imgX];

            // Start with black and add only the selected RGB channels
            let r = 0, g = 0, b = 0;

            // Add contributions from the top k RGB channels only
            topKChannels.forEach(channel => {
                if (channel.channel === 'R') r = originalR;
                if (channel.channel === 'G') g = originalG;
                if (channel.channel === 'B') b = originalB;
            });

            return [r, g, b];
        }

        function getRGBChannelsByStdDev() {
            // Calculate standard deviations for each RGB channel (same as RGB mode)
            let redSum = 0, greenSum = 0, blueSum = 0;
            let redSumSq = 0, greenSumSq = 0, blueSumSq = 0;
            const totalPixels = imageSize * imageSize;

            for (let i = 0; i < imageSize; i++) {
                for (let j = 0; j < imageSize; j++) {
                    const [r, g, b] = appState.imageData[i][j];

                    redSum += r;
                    greenSum += g;
                    blueSum += b;

                    redSumSq += r * r;
                    greenSumSq += g * g;
                    blueSumSq += b * b;
                }
            }

            // Calculate variance = E[X²] - (E[X])²
            const redMean = redSum / totalPixels;
            const greenMean = greenSum / totalPixels;
            const blueMean = blueSum / totalPixels;

            const redVariance = (redSumSq / totalPixels) - (redMean * redMean);
            const greenVariance = (greenSumSq / totalPixels) - (greenMean * greenMean);
            const blueVariance = (blueSumSq / totalPixels) - (blueMean * blueMean);

            // Take square root to get standard deviation
            const redStdDev = Math.sqrt(redVariance);
            const greenStdDev = Math.sqrt(greenVariance);
            const blueStdDev = Math.sqrt(blueVariance);

            // Create array of RGB channels with their standard deviations
            const channels = [
                { channel: 'R', stdDev: redStdDev },
                { channel: 'G', stdDev: greenStdDev },
                { channel: 'B', stdDev: blueStdDev }
            ];

            // Sort by standard deviation (descending) 
            channels.sort((a, b) => b.stdDev - a.stdDev);
            return channels;
        }

        function updateULabels() {
            for (let i = 0; i < 3; i++) {
                const label = document.getElementById(`uLabel${i}`);
                const shapeInfo = document.getElementById(`uShapeInfo${i}`);
                const isActive = (appState.hoveredVTRow === i) ||
                    (appState.isRankSliderActive && i < appState.currentRank) ||
                    (window.showFullRankHighlight && i < 3); if (isActive) {
                        // Calculate dynamic color based on V^T row (same as sigma bars)
                        const row = appState.svdResult.VT[i];
                        const rVal = Math.abs(row[0]);
                        const gVal = Math.abs(row[1]);
                        const bVal = Math.abs(row[2]);

                        // Normalize to 0-255 range for color display
                        const maxVal = Math.max(rVal, gVal, bVal);
                        let r = Math.floor((rVal / maxVal) * 255);
                        let g = Math.floor((gVal / maxVal) * 255);
                        let b = Math.floor((bVal / maxVal) * 255);

                        // Calculate luminance using standard formula
                        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                        // If the color is too light (luminance > 127), darken it for better contrast
                        if (luminance > 127) {
                            // Darken more aggressively by reducing all components proportionally
                            const darkenFactor = 0.7;
                            r = Math.floor(r * darkenFactor);
                            g = Math.floor(g * darkenFactor);
                            b = Math.floor(b * darkenFactor);
                        }

                        const dynamicColor = `rgb(${r}, ${g}, ${b})`;

                        label.innerHTML = `σ<sub>${i + 1}</sub>u<sub>${i + 1}</sub>v<sub>${i + 1}</sub><sup>T</sup>`;
                        label.style.color = dynamicColor;
                        shapeInfo.innerHTML = `[100 × 100 x 3]`;
                        shapeInfo.style.color = dynamicColor;
                    } else {
                    label.innerHTML = `U<sub>:,${i + 1}</sub>`;
                    label.style.color = '#333';
                    shapeInfo.innerHTML = `→ [100 × 100]`;
                    shapeInfo.style.color = '#666';
                }
            }
        }

        function drawUMatrix() {
            // Draw each U column as a separate square canvas
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);
                const ctx = canvas.getContext('2d');
                const canvasSize = CONFIG.U_CANVAS_SIZE; // Size of each individual canvas

                // Clear canvas
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // Find min/max for normalization for this column
                let minVal = Infinity, maxVal = -Infinity;
                for (let i = 0; i < appState.svdResult.U.length; i++) {
                    const val = appState.svdResult.U[i][col];
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                }

                // Determine if this column should be colored based on V^T hover or rank approximation
                const shouldColor = (appState.hoveredVTRow === col) ||
                    (appState.isRankSliderActive && col < appState.currentRank) ||
                    (window.showFullRankHighlight && col < 3);                // Draw column as square heatmap (unsquished)
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const idx = i * imageSize + j;
                        const val = appState.svdResult.U[idx][col];

                        if (shouldColor) {
                            // Use the exact same calculation as rank-1 components
                            const sigma = appState.svdResult.sigma[col];
                            const vRow = appState.svdResult.VT[col];
                            const uValue = appState.svdResult.U[idx][col];

                            // Calculate u_i * sigma_i * v_i^T for this pixel (same as rank-1 components)
                            const r = Math.max(0, Math.min(255, uValue * sigma * vRow[0] * 255));
                            const g = Math.max(0, Math.min(255, uValue * sigma * vRow[1] * 255));
                            const b = Math.max(0, Math.min(255, uValue * sigma * vRow[2] * 255));

                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            // Default grayscale
                            const normalized = (val - minVal) / (maxVal - minVal);
                            const intensity = Math.floor(normalized * 255);
                            ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                        }

                        // Map to square canvas coordinates
                        const x = (j / imageSize) * canvasSize;
                        const y = (i / imageSize) * canvasSize;
                        const w = canvasSize / imageSize;
                        const h = canvasSize / imageSize;

                        ctx.fillRect(x, y, w + 1, h + 1);
                    }
                }
            }

            // Set up hover interactions for each U matrix canvas
            setupUMatrixInteraction();
        }

        function setupUMatrixInteraction() {
            for (let col = 0; col < 3; col++) {
                const canvas = document.getElementById(`uMatrix${col}`);

                // Remove existing listeners to prevent duplicates
                canvas.onmouseover = null;
                canvas.onmouseleave = null;

                canvas.onmouseover = function () {
                    if (appState.hoveredVTRow !== col) {
                        appState.hoveredVTRow = col;
                        drawUMatrix(); // Redraw U matrix with coloring
                        drawSigmaMatrix(); // Redraw sigma matrix with coloring
                        drawVMatrix(); // Redraw V matrix with highlighting
                        updateULabels(); // Update labels to show principal component
                    }
                };

                canvas.onmouseleave = function () {
                    if (appState.hoveredVTRow === col) {
                        appState.hoveredVTRow = -1;
                        drawUMatrix(); // Redraw U matrix without coloring
                        drawSigmaMatrix(); // Redraw sigma matrix without coloring
                        drawVMatrix(); // Redraw V matrix without highlighting
                        updateULabels(); // Reset labels to original text
                    }
                };
            }
        }

        function drawSigmaMatrix() {
            const canvas = document.getElementById('sigmaMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // Draw singular values as bars
            const maxSigma = Math.max(...appState.svdResult.sigma);
            const barWidth = canvasSize / appState.svdResult.sigma.length;
            const margin = 20;

            for (let i = 0; i < appState.svdResult.sigma.length; i++) {
                const height = ((appState.svdResult.sigma[i] / maxSigma) * (canvasSize - 2 * margin));
                const x = i * barWidth + barWidth * 0.1;
                const y = canvasSize - margin - height;
                const w = barWidth * 0.8;

                // Calculate the color for this singular value based on corresponding V^T row
                let barColor = '#999'; // Default gray
                if ((appState.hoveredVTRow === i) || (appState.isRankSliderActive && i < appState.currentRank) || (window.showFullRankHighlight && i < 3)) {
                    // Get the RGB values for this V^T row (how this component mixes colors)
                    const row = appState.svdResult.VT[i];
                    const rVal = Math.abs(row[0]);
                    const gVal = Math.abs(row[1]);
                    const bVal = Math.abs(row[2]);

                    // Normalize to 0-255 range for color display
                    const maxVal = Math.max(rVal, gVal, bVal);
                    const r = Math.floor((rVal / maxVal) * 255);
                    const g = Math.floor((gVal / maxVal) * 255);
                    const b = Math.floor((bVal / maxVal) * 255);

                    barColor = `rgb(${r}, ${g}, ${b})`;
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(x, y, w, height);

                // Add value label
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(appState.svdResult.sigma[i].toFixed(1), i * barWidth + barWidth / 2, canvasSize - 5);
                ctx.fillText(`σ${i + 1}`, i * barWidth + barWidth / 2, y - 5);
            }

            // Set up hover interactions for sigma matrix
            setupSigmaMatrixInteraction(canvas, barWidth);
        }

        function setupSigmaMatrixInteraction(canvas, barWidth) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;

                // Determine which bar is being hovered
                const col = Math.floor(x / barWidth);

                if (col >= 0 && col < 3 && col !== appState.hoveredVTRow) {
                    appState.hoveredVTRow = col;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (appState.hoveredVTRow !== -1) {
                    appState.hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        function drawVMatrix() {
            const canvas = document.getElementById('vMatrix');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const cellSize = canvasSize / 3;

            // Find global min/max for consistent coloring
            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i < appState.svdResult.VT.length; i++) {
                for (let j = 0; j < appState.svdResult.VT[i].length; j++) {
                    minVal = Math.min(minVal, appState.svdResult.VT[i][j]);
                    maxVal = Math.max(maxVal, appState.svdResult.VT[i][j]);
                }
            }

            // Calculate row colors first for consistent coloring
            const rowColors = [];
            const rowNames = [];

            for (let i = 0; i < 3; i++) {
                const row = appState.svdResult.VT[i];

                // Get the RGB values for this row (how this component mixes colors)
                const rVal = Math.abs(row[0]);
                const gVal = Math.abs(row[1]);
                const bVal = Math.abs(row[2]);

                // Normalize to 0-255 range for color display
                const maxVal = Math.max(rVal, gVal, bVal);
                const r = Math.floor((rVal / maxVal) * 255);
                const g = Math.floor((gVal / maxVal) * 255);
                const b = Math.floor((bVal / maxVal) * 255);

                // Create a lighter version of the color for background (add transparency effect)
                const lightRowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
                const rowColor = `rgb(${r}, ${g}, ${b})`;

                rowColors.push({ light: lightRowColor, full: rowColor });

                // Determine the dominant color name
                if (rVal > gVal && rVal > bVal) {
                    rowNames.push('Red');
                } else if (gVal > rVal && gVal > bVal) {
                    rowNames.push('Green');
                } else {
                    rowNames.push('Blue');
                }
            }

            // Draw matrix cells with colored row backgrounds
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const val = appState.svdResult.VT[i][j];

                    // Use the row's light color as background (no color changes)
                    ctx.fillStyle = rowColors[i].light;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Draw normal border for all cells
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);

                    // Add value text (always black since we use light colors)
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        val.toFixed(3),
                        j * cellSize + cellSize / 2,
                        i * cellSize + cellSize / 2 + 5
                    );
                }
            }

            // Draw shadow box around hovered row or active rank components
            for (let i = 0; i < 3; i++) {
                // Check for RGB-specific highlighting when displaying RGB identity matrix
                const isRGBHighlighted = window.rgbHighlightRows &&
                    ((i === 0 && window.rgbHighlightRows.red) ||
                        (i === 1 && window.rgbHighlightRows.green) ||
                        (i === 2 && window.rgbHighlightRows.blue));

                const shouldHighlight = (appState.hoveredVTRow === i) ||
                    (appState.isRankSliderActive && i < appState.currentRank) ||
                    (window.showFullRankHighlight && i < 3) ||
                    isRGBHighlighted; if (shouldHighlight) {
                        const rowY = i * cellSize;
                        const margin = 6; // Margin to keep shadow within canvas bounds

                        // Create shadow effect
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;

                        // Draw shadow box around the entire row, inset by margin
                        ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(margin, rowY + margin, canvasSize - 2 * margin, cellSize - 2 * margin);

                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
            }

            // Draw row labels with full color backgrounds
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';

            for (let i = 0; i < 3; i++) {
                // Draw colored background for the row label
                const labelX = -45;
                const labelY = i * cellSize + cellSize / 2 - 7;
                const labelWidth = 40;
                const labelHeight = 14;

                ctx.fillStyle = rowColors[i].full;
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

                // Draw contrasting text
                const r = parseInt(rowColors[i].full.match(/\d+/g)[0]);
                const g = parseInt(rowColors[i].full.match(/\d+/g)[1]);
                const b = parseInt(rowColors[i].full.match(/\d+/g)[2]);
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                ctx.fillStyle = brightness > 127 ? 'black' : 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(rowNames[i], labelX + labelWidth / 2, labelY + 10);
            }

            // Add mouse event listeners for hover interaction
            setupVMatrixInteraction(canvas, cellSize);
        }

        function setupVMatrixInteraction(canvas, cellSize) {
            // Remove existing listeners to prevent duplicates
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            canvas.onmousemove = function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Determine which row is being hovered
                const row = Math.floor(y / cellSize);

                if (row >= 0 && row < 3 && row !== appState.hoveredVTRow) {
                    appState.hoveredVTRow = row;
                    drawUMatrix(); // Redraw U matrix with coloring
                    drawSigmaMatrix(); // Redraw sigma matrix with coloring
                    drawVMatrix(); // Redraw V matrix with highlighting
                    updateULabels(); // Update labels to show principal component
                }
            };

            canvas.onmouseleave = function () {
                if (appState.hoveredVTRow !== -1) {
                    appState.hoveredVTRow = -1;
                    drawUMatrix(); // Redraw U matrix without coloring
                    drawSigmaMatrix(); // Redraw sigma matrix without coloring
                    drawVMatrix(); // Redraw V matrix without highlighting
                    updateULabels(); // Reset labels to original text
                }
            };
        }

        init();
    </script>
</body>

</html>